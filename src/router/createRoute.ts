import { RouteParam } from "./params.ts";

export type RouteHandler<P extends string, R> = (
    params: RouteParam<P>,
) => R | null;
export type Route<R> = (url: string) => R | null;
export type RouteHandlerX<P extends string, X, R> = (
    params: RouteParam<P>,
    extra: X,
) => R | null;
export type RouteX<R, X> = (url: string, extra: X) => R | null;

/**
 * Create a route that request can get in.
 *
 * @param pattern specify the url matching pattern,
 * like `/user/<username>/<age>/<[extra]>/` can match url
 * `/user/miku/10/other/many/arguments/?timestamp=1641891955803`.
 *
 * @param handler is a function that can receive route matched
 * params and searchParams generated by URL class and return some
 * thing.
 *
 * @returns a function that receive a string as argument, if the
 * string matched the pattern, call the handler and return its
 * result, otherwise return null.
 */
export function createRoute<P extends string, R>(
    pattern: P,
    handler: RouteHandler<P, R>,
    flags?: string,
): Route<R> {
    const re = createRegExp(pattern, flags);
    return (url: string) => {
        const matched = re.exec(url);
        if (matched) {
            return handler(matched.groups as RouteParam<P>);
        }
        return null;
    };
}

/**
 * Create a route that request can get in.
 *
 * @param pattern specify the url matching pattern,
 * like `/user/<username>/<age>/<[extra]>` can match url
 * `/user/miku/10/other/many/arguments/?timestamp=1641891955803`.
 *
 * @param handler is a function that can receive route matched
 * params and searchParams generated by URL class and return some
 * thing.
 *
 * @returns a function that receive a string argument and
 * a extra arugment, if the string matched the pattern,
 * call the handler and return its result, otherwise return
 * null.
 */
export function createRouteX<P extends string, X, R>(
    pattern: P,
    handler: RouteHandlerX<P, X, R>,
    flags?: string,
): RouteX<R, X> {
    const re = createRegExp(pattern, flags);
    return (url: string, extra: X) => {
        const matched = re.exec(url);
        if (matched) {
            return handler(matched.groups as RouteParam<P>, extra);
        }
        return null;
    };
}

export function createRegExp<P extends string>(pattern: P, flags = "i") {
    const parsedPattern = pattern
        .replaceAll(/:<.+?>/g, (matched) => `(?${matched.slice(1)}[^\/]+?)`)
        .replaceAll(/:\{.+?\}/g, (matched) => `(?${matched.slice(1).replace("{", "<").replace("}", ">")}.+)`)
        .replaceAll(/\/:\(?.+?\)/g, (matched) => `((/(?${matched.slice(2).replace("(", "<").replace(")", ">")}.*))?)`)
        .replaceAll(/:\[.+?\]/g, (matched) => `(?${matched.slice(1).replace("[", "<").replace("]", ">")}.*)`);
    const endsWithSlash = parsedPattern.endsWith("/");
    return new RegExp(`^${parsedPattern}${endsWithSlash ? "" : "(\/?)"}$`, flags);
}
