<!DOCTYPE html><html class="default"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="IE=edge"/><title>Freesia - v0.8.19</title><meta name="description" content="Documentation for Freesia - v0.8.19"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="assets/style.css"/><link rel="stylesheet" href="assets/highlight.css"/><script async src="assets/search.js" id="search-script"></script></head><body><script>document.body.classList.add(localStorage.getItem("tsd-theme") || "os")</script><header><div class="tsd-page-toolbar"><div class="container"><div class="table-wrap"><div class="table-cell" id="tsd-search" data-base="."><div class="field"><label for="tsd-search-field" class="tsd-widget search no-caption">Search</label><input type="text" id="tsd-search-field"/></div><ul class="results"><li class="state loading">Preparing search index...</li><li class="state failure">The search index is not available</li></ul><a href="index.html" class="title">Freesia - v0.8.19</a></div><div class="table-cell" id="tsd-widgets"><div id="tsd-filter"><a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a><div class="tsd-filter-group"><div class="tsd-select" id="tsd-filter-visibility"><span class="tsd-select-label">All</span><ul class="tsd-select-list"><li data-value="public">Public</li><li data-value="protected">Public/Protected</li><li data-value="private" class="selected">All</li></ul></div> <input type="checkbox" id="tsd-filter-inherited" checked/><label class="tsd-widget" for="tsd-filter-inherited">Inherited</label><input type="checkbox" id="tsd-filter-externals" checked/><label class="tsd-widget" for="tsd-filter-externals">Externals</label></div></div><a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a></div></div></div></div><div class="tsd-page-title"><div class="container"><h1>Freesia - v0.8.19</h1></div></div></header><div class="container container-main"><div class="row"><div class="col-8 col-content"><div class="tsd-panel tsd-typography">
<a href="#freesia" id="freesia" style="color: inherit; text-decoration: none;">
  <h1>Freesia</h1>
</a>
<p>Freesia是一个Node.js的Web服务器开发的TypeScript库。</p>

<a href="#安装" id="安装" style="color: inherit; text-decoration: none;">
  <h2>安装</h2>
</a>
<pre><code class="language-sh"><span class="hl-1">npm install freesia</span><br/><span class="hl-1">npm install -D typescript @types/node</span>
</code></pre>

<a href="#response--frequest" id="response--frequest" style="color: inherit; text-decoration: none;">
  <h2>response = f(request)</h2>
</a>
<p>受到React中<code>UI = f(state)</code>的启发，Freesia库的核心观念是<code>response = f(request)</code>。当你使用Freesia库时，整个开发工作将围绕构建<code>f</code>函数展开。</p>
<p>一个最简单的<code>hello, world</code>程序对于Freesia而言应该是这样：</p>
<pre><code class="language-ts"><span class="hl-8">import</span><span class="hl-1"> { </span><span class="hl-5">createServer</span><span class="hl-1"> } </span><span class="hl-8">from</span><span class="hl-1"> </span><span class="hl-4">&quot;http&quot;</span><span class="hl-1">;</span><br/><span class="hl-8">import</span><span class="hl-1"> { </span><span class="hl-5">shimHTTP</span><span class="hl-1">, </span><span class="hl-5">createRes</span><span class="hl-1"> } </span><span class="hl-8">from</span><span class="hl-1"> </span><span class="hl-4">&quot;freesia&quot;</span><span class="hl-1">;</span><br/><span class="hl-3">createServer</span><span class="hl-1">(</span><span class="hl-3">shimHTTP</span><span class="hl-1">(</span><span class="hl-0">async</span><span class="hl-1"> </span><span class="hl-5">req</span><span class="hl-1"> </span><span class="hl-0">=&gt;</span><span class="hl-1"> </span><span class="hl-3">createRes</span><span class="hl-1">(</span><span class="hl-4">&quot;hello, world&quot;</span><span class="hl-1">))).</span><span class="hl-3">listen</span><span class="hl-1">(</span><span class="hl-9">8000</span><span class="hl-1">);</span>
</code></pre>
<p>核心的逻辑是<code>async req =&gt; createRes(&quot;hello, world&quot;)</code>，接受一个req对象作为参数，返回一个Response对象，正如React中传入props而返回JSX一样。</p>

<a href="#响应" id="响应" style="color: inherit; text-decoration: none;">
  <h2>响应</h2>
</a>
<p>从最基础的HTTP传输而言，响应内容值得关心的一般分为3个部分：状态码、响应头和响应主体。一些情况下，可能出现自定义状态消息的需求。对于Freesia的主函数而言，它应该返回一个符合<code>ResponseProps</code>定义的对象（或者<code>Promise&lt;ResponseProps&gt;</code>），它应该包含上述四种内容。例如：</p>
<pre><code class="language-ts"><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">response</span><span class="hl-1"> = {</span><br/><span class="hl-1">    </span><span class="hl-5">statusCode:</span><span class="hl-1"> </span><span class="hl-9">200</span><span class="hl-1">, </span><span class="hl-10">// 一切有效的HTTP状态码</span><br/><span class="hl-1">    </span><span class="hl-5">statusMessage:</span><span class="hl-1"> </span><span class="hl-4">&quot;Ok&quot;</span><span class="hl-1">, </span><span class="hl-10">// 状态消息对HTTP/2是无效的，现代客户端有时也并不接受自定义状态消息</span><br/><span class="hl-1">    </span><span class="hl-5">body:</span><span class="hl-1"> </span><span class="hl-4">&quot;hello, world&quot;</span><span class="hl-1">, </span><span class="hl-10">// body可以是一个字符串，Buffer或者可读的Node.js流</span><br/><span class="hl-1">    </span><span class="hl-5">headers:</span><span class="hl-1"> {</span><span class="hl-4">&quot;Content-Type&quot;</span><span class="hl-5">:</span><span class="hl-1"> </span><span class="hl-4">&quot;text/plain; charset=UTF-8&quot;</span><span class="hl-1">} </span><span class="hl-10">// headers的key是string，value是string|string[]|number</span><br/><span class="hl-1">}</span>
</code></pre>
<p>除去手动声明之外，Freesia还提供了一个<code>Respond</code>类来帮助创建响应对象。</p>

<a href="#respond类" id="respond类" style="color: inherit; text-decoration: none;">
  <h3>Respond类</h3>
</a>
<p>创建<code>Respond</code>对象的方法有如下三种：</p>
<pre><code class="language-ts"><span class="hl-8">import</span><span class="hl-1"> { </span><span class="hl-5">Respond</span><span class="hl-1">, </span><span class="hl-5">createRes</span><span class="hl-1"> } </span><span class="hl-8">from</span><span class="hl-1"> </span><span class="hl-4">&quot;freesia&quot;</span><span class="hl-1">;</span><br/><span class="hl-10">// new Respond</span><br/><span class="hl-0">new</span><span class="hl-1"> </span><span class="hl-3">Respond</span><span class="hl-1">()</span><br/><span class="hl-1">    .</span><span class="hl-3">setBody</span><span class="hl-1">(</span><span class="hl-4">&quot;hello, world&quot;</span><span class="hl-1">)</span><br/><span class="hl-1">    .</span><span class="hl-3">setHeaders</span><span class="hl-1">([</span><span class="hl-4">&quot;Content-Type&quot;</span><span class="hl-1">, </span><span class="hl-4">&quot;text/plain; charset=UTF-8&quot;</span><span class="hl-1">])</span><br/><span class="hl-1">    .</span><span class="hl-3">setHeaders</span><span class="hl-1">([</span><span class="hl-4">&quot;Content-Length&quot;</span><span class="hl-1">, </span><span class="hl-9">12</span><span class="hl-1">]);</span><br/><span class="hl-5">Respond</span><span class="hl-1">.</span><span class="hl-3">create</span><span class="hl-1">(</span><span class="hl-4">&quot;hello, world&quot;</span><span class="hl-1">, {</span><span class="hl-4">&quot;Content-Type&quot;</span><span class="hl-5">:</span><span class="hl-1"> </span><span class="hl-4">&quot;text/plain; charset=UTF-8&quot;</span><span class="hl-1">, </span><span class="hl-4">&quot;Content-Length&quot;</span><span class="hl-5">:</span><span class="hl-1"> </span><span class="hl-9">12</span><span class="hl-1">});</span><br/><span class="hl-3">createRes</span><span class="hl-1">(</span><span class="hl-4">&quot;hello, world&quot;</span><span class="hl-1">, {</span><span class="hl-4">&quot;Content-Type&quot;</span><span class="hl-5">:</span><span class="hl-1"> </span><span class="hl-4">&quot;text/plain; charset=UTF-8&quot;</span><span class="hl-1">, </span><span class="hl-4">&quot;Content-Length&quot;</span><span class="hl-5">:</span><span class="hl-1"> </span><span class="hl-9">12</span><span class="hl-1">});</span>
</code></pre>
<p>其中，<code>createRes</code>是<code>Respond.create</code>的别名，这两个方法比<code>new Respond()</code>更加简便，提供了多种重载用于一次性建立一个响应对象，参考<a href="https://qihexiang.github.io/freesia/classes/Respond.html#create">API文档</a>。</p>
<p><code>Respond</code>对象包含如下方法：</p>
<ul>
<li>setStatusCode</li>
<li>setStatusMessage</li>
<li>setBody</li>
<li>setHeaders</li>
</ul>
<p>用于设置对象对应的属性，其中前三种方法每次调用会替代掉前一次调用的结果，而<code>setHeaders</code>方法则会在每次调用时将新的响应头合并到之间的结果中，例如上面调用中的两次<code>setHeaders</code>设置的响应头都是有效的。此外，setHeaders还支持多种格式的输入，请参考<a href="https://qihexiang.github.io/freesia/classes/Respond.html#setHeaders">API文档</a>。</p>
<p>Freesia提供了一些函数来配合<code>setHeaders</code>方法的使用，例如：</p>
<pre><code class="language-ts"><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">message</span><span class="hl-1"> = </span><span class="hl-4">&quot;hello, world</span><span class="hl-11">\n</span><span class="hl-4">&quot;</span><span class="hl-1">;</span><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">response</span><span class="hl-1"> = </span><span class="hl-3">createRes</span><span class="hl-1">(</span><span class="hl-9">200</span><span class="hl-1">, </span><span class="hl-5">message</span><span class="hl-1">)</span><br/><span class="hl-1">    .</span><span class="hl-3">setHeaders</span><span class="hl-1">(</span><br/><span class="hl-1">        </span><span class="hl-3">contentType</span><span class="hl-1">(</span><span class="hl-4">&quot;txt&quot;</span><span class="hl-1">, </span><span class="hl-4">&quot;UTF-8&quot;</span><span class="hl-1">), </span><br/><span class="hl-1">        </span><span class="hl-3">contentLength</span><span class="hl-1">(</span><span class="hl-5">message</span><span class="hl-1">), </span><br/><span class="hl-1">        </span><span class="hl-3">contentDisposition</span><span class="hl-1">(</span><span class="hl-0">true</span><span class="hl-1">, </span><span class="hl-4">&quot;helloWorld.txt&quot;</span><span class="hl-1">)</span><br/><span class="hl-1">    );</span>
</code></pre>

<a href="#路由" id="路由" style="color: inherit; text-decoration: none;">
  <h2>路由</h2>
</a>
<p>由于函数式的设计，这个库并不包含像express那样的<code>app.get(pattern, handler)</code>风格的路由，而是通过工具函数来实现请求路径的区分的。</p>

<a href="#路由（route）" id="路由（route）" style="color: inherit; text-decoration: none;">
  <h3>路由（Route）</h3>
</a>
<p>路由在Freesia中的概念是，当用户访问的路径符合某一个规则的时候，则执行对应的函数，并获得函数的返回值。要创建一个路由，使用<code>createRoute</code>函数来实现。</p>
<p><code>createRoute</code>中可以传入两个参数，第一个是路由匹配模式<code>pattern</code>，格式像这样：<code>/user/&lt;username&gt;/&lt;age&gt;/</code>，这样，就可以匹配到类似于<code>/user/freesia/16/</code>这样的路径。</p>
<p>表明路径参数的形式有三种：</p>
<ul>
<li><code>&lt;T&gt;</code>：非贪婪模式，匹配任意字符出现至少一次。</li>
<li><code>&lt;[T]&gt;</code>：贪婪模式，匹配任意字符至少出现一次。</li>
<li><code>[T]</code>：贪婪模式，匹配任意字符，也可以没有字符。</li>
</ul>
<p>可以观看这个例子中，对<code>filepath</code>的捕获情况来理解：</p>
<table>
<thead>
<tr>
<th>模式/路径</th>
<th><code>/user/hx/docs/index.md</code></th>
<th><code>/user/hx/docs/index.md/</code></th>
<th><code>/user/hx/</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>/user/&lt;name&gt;/&lt;filepath&gt;/</code></td>
<td><code>null</code></td>
<td><code>null</code></td>
<td><code>null</code></td>
</tr>
<tr>
<td><code>/user/&lt;name&gt;/&lt;filepath&gt;</code></td>
<td><code>&quot;docs/index.md&quot;</code></td>
<td><code>&quot;docs/index.md/&quot;</code></td>
<td><code>null</code></td>
</tr>
<tr>
<td><code>/user/&lt;name&gt;/&lt;[filepath]&gt;/</code></td>
<td><code>null</code></td>
<td><code>&quot;doc/index.md&quot;</code></td>
<td><code>null</code></td>
</tr>
<tr>
<td><code>/user/&lt;name&gt;/[filepath]</code></td>
<td><code>&quot;docs/index.md&quot;</code></td>
<td><code>&quot;docs/index.md/&quot;</code></td>
<td><code>&quot;&quot;</code></td>
</tr>
</tbody></table>
<p>另一个参数自然是对应的函数<code>handler</code>，这个函数的参数是根据<code>pattern</code>推导出的路由匹配参数<code>params</code>，例如上面的例子中，推导出的参数类型为<code>{name: string, filepath: string}</code>，所有的路由参数类型都是<code>string</code>，开发者应该根据实际的情况进行检查和类型转换。</p>
<p>下面是一个示例：</p>
<pre><code class="language-js"><span class="hl-8">import</span><span class="hl-1"> { </span><span class="hl-5">createRoute</span><span class="hl-1"> } </span><span class="hl-8">from</span><span class="hl-1"> </span><span class="hl-4">&quot;freesia&quot;</span><span class="hl-1"> </span><br/><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">route</span><span class="hl-1"> = </span><span class="hl-3">createRoute</span><span class="hl-1">(</span><span class="hl-4">&#39;/user/&lt;username&gt;/&lt;filepath&gt;&#39;</span><span class="hl-1">, </span><span class="hl-3">async</span><span class="hl-1"> ({</span><span class="hl-5">username</span><span class="hl-1">, </span><span class="hl-5">filepath</span><span class="hl-1">}) </span><br/><span class="hl-1">    </span><span class="hl-0">=&gt;</span><span class="hl-1"> </span><span class="hl-7">JSON</span><span class="hl-1">.</span><span class="hl-3">stringify</span><span class="hl-1">(</span><span class="hl-8">await</span><span class="hl-1"> </span><span class="hl-3">readDir</span><span class="hl-1">(</span><span class="hl-5">username</span><span class="hl-1">, </span><span class="hl-5">filepath</span><span class="hl-1">)))</span><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">result</span><span class="hl-1"> = </span><span class="hl-8">await</span><span class="hl-1"> </span><span class="hl-3">route</span><span class="hl-1">(</span><span class="hl-5">url</span><span class="hl-1">)</span>
</code></pre>

<a href="#交换机（switcher）" id="交换机（switcher）" style="color: inherit; text-decoration: none;">
  <h3>交换机（Switcher）</h3>
</a>
<p>每个Route只是一条路径，实际上需要使用多条路径进行依次匹配。使用交换机（Switcher）实现该功能。例如有路由<code>route1</code>-<code>route6</code>，他们的<code>handler</code>拥有相同的返回类型，则可以聚合在一起。</p>
<blockquote>
<p>返回类型不同的平级路由，使用联合类型作为Switcher的泛型类型。</p>
</blockquote>
<p>方式如下：</p>
<pre><code class="language-js"><span class="hl-8">import</span><span class="hl-1"> { </span><span class="hl-5">createSwitcher</span><span class="hl-1"> } </span><span class="hl-8">from</span><span class="hl-1"> </span><span class="hl-4">&quot;freesia&quot;</span><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">switcher</span><span class="hl-1"> = </span><span class="hl-3">createSwitcher</span><span class="hl-1">(</span><span class="hl-5">route1</span><span class="hl-1">, </span><span class="hl-5">route2</span><span class="hl-1">, </span><span class="hl-5">route3</span><span class="hl-1">, </span><span class="hl-5">route4</span><span class="hl-1">, </span><span class="hl-5">route5</span><span class="hl-1">, </span><span class="hl-5">route6</span><span class="hl-1">)</span><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">result</span><span class="hl-1"> = </span><span class="hl-3">switcher</span><span class="hl-1">(</span><span class="hl-5">url</span><span class="hl-1">)</span>
</code></pre>
<p>Switcher最终得到的函数和Route实际上是一样的，因此可以逐级将多个Switcher也聚合起来。</p>
<blockquote>
<p>注意，由于<code>switcher</code>的实现使用了<code>??</code>运算符（判断匹配失败的依据是路由返回<code>null</code>），因此当你需要返回<code>null</code>或<code>undefined</code>时，必须将其包裹起来，例如<code>{ value: null }</code>。</p>
</blockquote>

<a href="#额外参数" id="额外参数" style="color: inherit; text-decoration: none;">
  <h3>额外参数</h3>
</a>
<p>在实际使用中，<code>handler</code>往往还需要其他参数的输入，你可以这样来获得额外参数：</p>
<pre><code class="language-ts"><span class="hl-8">import</span><span class="hl-1"> </span><span class="hl-5">apiRouteHandler</span><span class="hl-1"> </span><span class="hl-8">from</span><span class="hl-1"> </span><span class="hl-4">&quot;./controller/api&quot;</span><br/><span class="hl-8">import</span><span class="hl-1"> </span><span class="hl-5">DB</span><span class="hl-1"> </span><span class="hl-8">from</span><span class="hl-1"> </span><span class="hl-4">&quot;./data/IO&quot;</span><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">db</span><span class="hl-1"> = </span><span class="hl-0">new</span><span class="hl-1"> </span><span class="hl-3">DB</span><span class="hl-1">();</span><br/><br/><span class="hl-0">function</span><span class="hl-1"> </span><span class="hl-3">main</span><span class="hl-1">(</span><span class="hl-5">req</span><span class="hl-1">: </span><span class="hl-7">Request</span><span class="hl-1">) {</span><br/><span class="hl-1">    </span><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">result</span><span class="hl-1"> = </span><span class="hl-8">await</span><span class="hl-1"> </span><span class="hl-3">createRoute</span><span class="hl-1">(</span><span class="hl-4">&quot;/api/&lt;options&gt;&quot;</span><span class="hl-1">, ({</span><span class="hl-5">options</span><span class="hl-1">}) </span><span class="hl-0">=&gt;</span><span class="hl-1"> </span><span class="hl-3">apiRouteHandler</span><span class="hl-1">(</span><span class="hl-5">options</span><span class="hl-1">, {</span><span class="hl-5">req</span><span class="hl-1">, </span><span class="hl-5">db</span><span class="hl-1">}))(</span><span class="hl-5">req</span><span class="hl-1">.</span><span class="hl-5">url</span><span class="hl-1">)</span><br/><span class="hl-1">    </span><span class="hl-8">return</span><span class="hl-1"> </span><span class="hl-5">result</span><br/><span class="hl-1">}</span>
</code></pre>
<p>但如果我们想将路径和控制器绑定之后再接收参数的话，就无法做到了。因此，本库中提供了额外的函数：<code>createExtendRoute</code>。它的使用与<code>createRoute</code>基本相同，差异在于它的<code>handler</code>可以接受一个额外的自定义类型参数；返回的路由匹配时也可以接收一个对应的参数。例如上面的例子会变成：</p>
<pre><code class="language-ts"><span class="hl-10">// controller/api.ts</span><br/><span class="hl-8">export</span><span class="hl-1"> </span><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">apiRoute</span><span class="hl-1"> = </span><span class="hl-3">createExtendRoute</span><span class="hl-1">(</span><span class="hl-4">&#39;/api/&lt;options&gt;&#39;</span><span class="hl-1">, ({</span><span class="hl-5">options</span><span class="hl-1">}, {</span><span class="hl-5">req</span><span class="hl-1">: </span><span class="hl-5">Request</span><span class="hl-1">, </span><span class="hl-5">db</span><span class="hl-1">: </span><span class="hl-5">DB</span><span class="hl-1">}) </span><span class="hl-0">=&gt;</span><span class="hl-1"> {...})</span><br/><br/><span class="hl-10">// main.ts</span><br/><span class="hl-8">import</span><span class="hl-1"> { </span><span class="hl-5">apiRoute</span><span class="hl-1"> } </span><span class="hl-8">from</span><span class="hl-1"> </span><span class="hl-4">&quot;./controller/api&quot;</span><br/><span class="hl-8">import</span><span class="hl-1"> </span><span class="hl-5">DB</span><span class="hl-1"> </span><span class="hl-8">from</span><span class="hl-1"> </span><span class="hl-4">&quot;./data/IO&quot;</span><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">db</span><span class="hl-1"> = </span><span class="hl-0">new</span><span class="hl-1"> </span><span class="hl-3">DB</span><span class="hl-1">();</span><br/><br/><span class="hl-0">function</span><span class="hl-1"> </span><span class="hl-3">main</span><span class="hl-1">(</span><span class="hl-5">req</span><span class="hl-1">: </span><span class="hl-7">Request</span><span class="hl-1">) {</span><br/><span class="hl-1">    </span><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">route</span><span class="hl-1"> = </span><span class="hl-8">await</span><span class="hl-1"> </span><span class="hl-3">apiRoute</span><span class="hl-1">(</span><span class="hl-5">req</span><span class="hl-1">.</span><span class="hl-5">url</span><span class="hl-1">, {</span><span class="hl-5">req</span><span class="hl-1">, </span><span class="hl-5">db</span><span class="hl-1">})</span><br/><span class="hl-1">    </span><span class="hl-8">return</span><span class="hl-1"> </span><span class="hl-5">result</span><br/><span class="hl-1">}</span>
</code></pre>
<p>若有多个这样的扩展路由进行聚合时，可以使用<code>createExtendSwitcher</code>来创建交换机。</p>

<a href="#同时创建路由和交换机" id="同时创建路由和交换机" style="color: inherit; text-decoration: none;">
  <h4>同时创建路由和交换机</h4>
</a>
<p>利用<code>createRoute</code>和<code>createSwitcher</code>，我们可以在分离的多个地方对路由规则进行定义，但与此同时，也会有人更倾向与将路径匹配模式集中定义于一处，此时重复使用<code>createRoute</code>和<code>createSwitcher</code>就显得十分麻烦。Freesia提供了一个额外的函数<code>createSwRt</code>来实现这个功能，他提供一个链试调用来创建一个交换机及其对应的路由。</p>
<p>例子如下，有若干已经定义好的<code>handler</code>，它们返回的值类型相互匹配（例如<code>Promise&lt;ResponseProps&gt;</code>）。</p>
<pre><code class="language-js"><span class="hl-8">import</span><span class="hl-1"> { </span><span class="hl-5">createSwRt</span><span class="hl-1"> } </span><span class="hl-8">from</span><span class="hl-1"> </span><span class="hl-4">&quot;freesia&quot;</span><br/><br/><span class="hl-0">async</span><span class="hl-1"> </span><span class="hl-0">function</span><span class="hl-1"> </span><span class="hl-3">main</span><span class="hl-1">(</span><span class="hl-5">req</span><span class="hl-1">) {</span><br/><span class="hl-1">    </span><span class="hl-0">const</span><span class="hl-1"> { </span><span class="hl-2">switcher</span><span class="hl-1"> } = </span><span class="hl-3">createSwRt</span><span class="hl-1">()</span><br/><span class="hl-1">        .</span><span class="hl-3">route</span><span class="hl-1">(</span><span class="hl-4">&quot;/user/&lt;username&gt;/&lt;rest&gt;&quot;</span><span class="hl-1">, </span><span class="hl-5">infoHandler</span><span class="hl-1">)</span><br/><span class="hl-1">        .</span><span class="hl-3">route</span><span class="hl-1">(</span><span class="hl-4">&quot;/view/&lt;rest&gt;&quot;</span><span class="hl-1">, </span><span class="hl-5">viewHandler</span><span class="hl-1">)</span><br/><span class="hl-1">        .</span><span class="hl-3">route</span><span class="hl-1">(</span><span class="hl-4">&quot;/d/&lt;username&gt;/&lt;filepath&gt;&quot;</span><span class="hl-1">, </span><span class="hl-5">downloadHandler</span><span class="hl-1">)</span><br/><span class="hl-1">        .</span><span class="hl-3">route</span><span class="hl-1">(</span><span class="hl-4">&quot;/b/&lt;username&gt;/&lt;[filepath]&gt;/&quot;</span><span class="hl-1">, </span><span class="hl-5">browseHandler</span><span class="hl-1">)</span><br/><span class="hl-1">        .</span><span class="hl-3">fallback</span><span class="hl-1">(</span><span class="hl-0">async</span><span class="hl-1"> </span><span class="hl-5">url</span><span class="hl-1"> </span><span class="hl-0">=&gt;</span><span class="hl-1"> </span><span class="hl-3">createRes</span><span class="hl-1">(</span><span class="hl-9">404</span><span class="hl-1">, </span><span class="hl-4">`No route matched </span><span class="hl-0">${</span><span class="hl-5">url</span><span class="hl-0">}</span><span class="hl-4">`</span><span class="hl-1">))</span><br/><span class="hl-1">    </span><span class="hl-8">return</span><span class="hl-1"> </span><span class="hl-3">switcher</span><span class="hl-1">(</span><span class="hl-5">url</span><span class="hl-1">)</span><br/><span class="hl-1">}</span>
</code></pre>
<p><code>route</code>和<code>fallback</code>函数会检查<code>handler</code>的返回类型是否一致，一致性的依据是第一个被调用的<code>route</code>方法的传入参数，如果要手动指定返回类型，例如有的<code>handler</code>返回异步结果，有的返回同步结果，则应该在第一次调用<code>route</code>时明确泛型类型，<code>.route&lt;Promise&lt;ResponseProps&gt;&gt;|ResponseProps&gt;</code>。后续的<code>route</code>函数和第一个<code>route</code>并不是同一个函数，他们没有泛型参数。</p>
<blockquote>
<p>请务必不要通过导出<code>createSwRt</code>的执行结果来在多个文件中注册路由：<br>第一次返回的<code>route</code>方法实际上会返回一个全新的对象，多次调用并不能将多个路由注册到一个交换机上，而是产生多个交换机；<br>之后的<code>route</code>方法可以在多处调用并注册路由到同一个交换机，但是注册的顺序取决于模块导入导出的逻辑，这会使得路由顺序和你设想的不一致；<br><code>fallback</code>方法并不会更新闭包，除非你使用它的返回值，否则这个注册是无效的。</p>
</blockquote>
<p>每次链式调用中的<code>route</code>函数和<code>createRoute</code>函数参数类型一致，返回中解析出的<code>switcher</code>和<code>createSwitcher</code>的类型是一致的。</p>
<p>另外，提供了一个<code>createExtendSwRt</code>函数，使用方法基本一致。</p>

<a href="#简单匹配（condition）" id="简单匹配（condition）" style="color: inherit; text-decoration: none;">
  <h3>简单匹配（Condition）</h3>
</a>
<p>上述的路由匹配模式只能支持URL的路径匹配，但实际上我们还会根据一些具体的情况，例如请求的方法、可枚举的具体路径参数等进行请求分流，这些情况一般需要精确匹配字符串。这使用上面的函数并不容易实现，或者显得更加麻烦，因此提供了一个<code>condition</code>函数，以链试调用的方式来实现类似与switch语法的功能，可以看作是一个带有返回值的switch块。</p>
<pre><code class="language-js"><span class="hl-8">import</span><span class="hl-1"> { </span><span class="hl-5">condition</span><span class="hl-1"> } </span><span class="hl-8">from</span><span class="hl-1"> </span><span class="hl-4">&quot;freesia&quot;</span><br/><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">result</span><span class="hl-1"> = </span><span class="hl-3">condition</span><span class="hl-1">(</span><span class="hl-5">req</span><span class="hl-1">.</span><span class="hl-5">method</span><span class="hl-1">)</span><br/><span class="hl-1">    .</span><span class="hl-3">match</span><span class="hl-1">(</span><span class="hl-4">&#39;GET&#39;</span><span class="hl-1">, () </span><span class="hl-0">=&gt;</span><span class="hl-1"> </span><span class="hl-3">getSw</span><span class="hl-1">(</span><span class="hl-5">req</span><span class="hl-1">.</span><span class="hl-5">url</span><span class="hl-1">))</span><br/><span class="hl-1">    .</span><span class="hl-3">match</span><span class="hl-1">([</span><span class="hl-4">&#39;POST&#39;</span><span class="hl-1">,</span><span class="hl-4">&#39;PUT&#39;</span><span class="hl-1">], () </span><span class="hl-0">=&gt;</span><span class="hl-1"> </span><span class="hl-3">uploadSw</span><span class="hl-1">(</span><span class="hl-5">req</span><span class="hl-1">.</span><span class="hl-5">url</span><span class="hl-1">, </span><span class="hl-5">req</span><span class="hl-1">))</span><br/><span class="hl-1">    .</span><span class="hl-3">match</span><span class="hl-1">(</span><span class="hl-12">/</span><span class="hl-13">^</span><span class="hl-14">(</span><span class="hl-12">OPTION</span><span class="hl-13">|</span><span class="hl-12">TRACE</span><span class="hl-14">)</span><span class="hl-13">$</span><span class="hl-12">/</span><span class="hl-1">, (</span><span class="hl-5">method</span><span class="hl-1">) </span><span class="hl-0">=&gt;</span><span class="hl-1"> </span><span class="hl-3">debugSw</span><span class="hl-1">(</span><span class="hl-5">req</span><span class="hl-1">.</span><span class="hl-5">url</span><span class="hl-1">, </span><span class="hl-5">method</span><span class="hl-1">))</span><br/><span class="hl-1">    .</span><span class="hl-3">getValue</span><span class="hl-1">()</span>
</code></pre>
<p>例如，这个例子分流的依据是<code>req.method</code>，我们将<code>GET</code>请求分为一组，<code>POST</code>和<code>PUT</code>请求分为一组。调用链中，<code>match</code>的一个参数是字符串或字符串数组，当字符串和分流依据相等，或数组中存在匹配的字符串时，或给定的正则表达式与分流依据匹配时，会执行后续的<code>handler</code>，所有注册的<code>handler</code>应该有相同的返回类型或符合<code>condition&lt;T&gt;</code>描述的泛型。解构出的<code>result</code>是<code>handler</code>的返回值。</p>
<p>获得返回值有两种方法：<code>getValue</code>和<code>withDefault</code>，后者接受一个回调函数，来根据输入的值返回一个值。</p>

<a href="#useurl" id="useurl" style="color: inherit; text-decoration: none;">
  <h3>useURL</h3>
</a>
<p><code>useURL</code>函数可以在<code>shimHTTP</code>的回调函数的任意层次调用中获得这个请求的路径信息，使用方法为：</p>
<pre><code class="language-ts"><span class="hl-3">useURL</span><span class="hl-1">() </span><span class="hl-10">// 返回host（主机名）、path（访问路径）、query（搜索参数的searchParams）</span><br/><span class="hl-3">useURL</span><span class="hl-1">(</span><span class="hl-4">&quot;host&quot;</span><span class="hl-1">) </span><span class="hl-10">// 返回host</span><br/><span class="hl-3">useURL</span><span class="hl-1">(</span><span class="hl-4">&quot;path&quot;</span><span class="hl-1">) </span><span class="hl-10">// 返回path</span><br/><span class="hl-3">useURL</span><span class="hl-1">(</span><span class="hl-4">&quot;query&quot;</span><span class="hl-1">) </span><span class="hl-10">// 返回query</span><br/><span class="hl-3">useURL</span><span class="hl-1">(</span><span class="hl-5">router</span><span class="hl-1">) </span><span class="hl-10">// Route&lt;T&gt;的路由，返回路由匹配结果。</span>
</code></pre>

<a href="#闪光弹和userequest" id="闪光弹和userequest" style="color: inherit; text-decoration: none;">
  <h2>闪光弹和useRequest</h2>
</a>
<p>编写代码时一个常见的问题是，在某个函数中生成的某个值可能会在多层间接调用的另一个函数中使用，使用函数传值的方式进行传递会非常麻烦。我们会希望有一种方式能够将一些变量进行“广播”，使得之后任意层次调用的函数都可以访问到这个值。</p>
<p>Freesia提供了类似React上下文的功能（和请求绑定）。用<code>createFlare</code>函数来创建闪光弹，</p>
<p>它可以接受0或1个参数，若有参数，是一个对象，包含两项属性：</p>
<ul>
<li><code>mutable</code>：若为<code>true</code>，则观测得到的值不是只读的，如果你要使用闪光弹传递一个ORM对象，它应该设置为true；</li>
<li><code>reassign</code>：若为<code>true</code>，可以多次使用light函数重新给闪光弹赋值，一般没有理由这么做。</li>
<li>不输入参数时，上述属性默认为<code>false</code></li>
</ul>
<p>它返回三个函数：</p>
<ul>
<li><code>light</code>：点燃闪光弹，这个函数调用之后，要被传递的值就可以通过<code>observe</code>函数访问了；</li>
<li><code>observe</code>：观测闪光弹，执行这个函数可以得到要传递的值，它必须在<code>light</code>函数之后调用；</li>
<li><code>extinguish</code>：熄灭闪光弹，执行这个函数之后，<code>observe</code>将不能再被使用</li>
</ul>
<blockquote>
<p>这三个函数是通过数组返回的，你可以给他们取任意需要的名字。</p>
</blockquote>
<pre><code class="language-ts"><span class="hl-10">// 调用次序为：main -&gt; fileRoute -&gt; uploadRoute -&gt; uploadHandler -&gt; uploadService</span><br/><span class="hl-10">// 我们不想逐层传递request对像来获得上传的body，我们在main函数获得body后，将其用</span><br/><span class="hl-10">// main.ts</span><br/><span class="hl-8">export</span><span class="hl-1"> </span><span class="hl-0">const</span><span class="hl-1"> [</span><span class="hl-2">light</span><span class="hl-1">, </span><span class="hl-2">observe</span><span class="hl-1">, </span><span class="hl-2">extinguish</span><span class="hl-1">] = </span><span class="hl-3">createFlare</span><span class="hl-1">&lt;</span><span class="hl-7">Buffer</span><span class="hl-1">&gt;()</span><br/><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-3">main</span><span class="hl-1"> = </span><span class="hl-0">async</span><span class="hl-1"> </span><span class="hl-5">req</span><span class="hl-1"> </span><span class="hl-0">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">body</span><span class="hl-1"> = </span><span class="hl-8">await</span><span class="hl-1"> </span><span class="hl-3">rawBody</span><span class="hl-1">(</span><span class="hl-5">req</span><span class="hl-1">);</span><br/><span class="hl-1">    </span><span class="hl-3">light</span><span class="hl-1">(</span><span class="hl-5">body</span><span class="hl-1">); </span><span class="hl-10">// 从此向下的调用可以通过observe函数访问body</span><br/><span class="hl-1">    ...</span><br/><span class="hl-1">    </span><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">res</span><span class="hl-1"> = </span><span class="hl-3">fileRoute</span><span class="hl-1">(); </span><span class="hl-10">// 不需要传递body</span><br/><span class="hl-1">    ...</span><br/><span class="hl-1">    </span><span class="hl-3">extinguish</span><span class="hl-1">(); </span><span class="hl-10">// 从此向下的调用不能再通过observe访问body</span><br/><span class="hl-1">    </span><span class="hl-8">return</span><span class="hl-1"> </span><span class="hl-5">res</span><br/><span class="hl-1">}</span><br/><br/><span class="hl-10">// service/fileUpload.ts</span><br/><span class="hl-8">import</span><span class="hl-1"> {</span><span class="hl-5">observe</span><span class="hl-1">} </span><span class="hl-8">from</span><span class="hl-1"> </span><span class="hl-4">&quot;../main&quot;</span><span class="hl-1">;</span><br/><span class="hl-8">import</span><span class="hl-1"> {</span><span class="hl-5">writeFile</span><span class="hl-1">} </span><span class="hl-8">from</span><span class="hl-1"> </span><span class="hl-4">&quot;fs/promises&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-8">export</span><span class="hl-1"> </span><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-3">uploadService</span><span class="hl-1"> = (</span><span class="hl-5">filepath</span><span class="hl-1">: </span><span class="hl-7">string</span><span class="hl-1">) </span><span class="hl-0">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">body</span><span class="hl-1"> = </span><span class="hl-3">observe</span><span class="hl-1">(); </span><span class="hl-10">// 获得body</span><br/><span class="hl-1">    </span><span class="hl-8">return</span><span class="hl-1"> </span><span class="hl-3">writeFile</span><span class="hl-1">(</span><span class="hl-5">filepath</span><span class="hl-1">, </span><span class="hl-5">body</span><span class="hl-1">)</span><br/><span class="hl-1">}</span>
</code></pre>
<blockquote>
<p>需要注意的以下几点：</p>
<ul>
<li><code>createFlare</code>不是完全独立的函数，它返回的三个函数都只能在<code>shimHTTP</code>的直接或间接调用中执行，否则会抛出错误</li>
<li>静态分析时<code>light</code>，<code>observe</code>和<code>extinguish</code>并不能判断要获取的值是否处于有效期，因此这三个函数会在不符合执行条件的情况下抛出错误。（而不是返回<code>undefined</code>或<code>null</code>）</li>
<li><code>extinguish</code>函数不是必须执行的，<code>createFlare</code>内部使用的是<code>WeakMap</code>实现的，不必担心内存溢出的问题。</li>
</ul>
</blockquote>
<p>在Freesia中，最常使用的一个对象可能是入口函数传入的<code>req</code>变量，因此提供了<code>useRequest</code>函数来随时获得这个值，你不需要将其层层传递下去。</p>

<a href="#包装器" id="包装器" style="color: inherit; text-decoration: none;">
  <h2>包装器</h2>
</a>
<p>开发者可能会希望在一个函数执行前后分别执行一些代码，这些代码可能是可服复用的，也有可能只是希望这些逻辑被排除在核心逻辑之外，出于这样的需求，Freesia提供了两个包装器创建函数：<code>createEffect</code>和<code>createWrapper</code>。</p>

<a href="#副作用包装" id="副作用包装" style="color: inherit; text-decoration: none;">
  <h3>副作用包装</h3>
</a>
<p>如果我们的包装逻辑并不修改原始函数的输入输出，可以使用副作用包装器<code>createEffect</code>。例如，要测量响应逻辑耗时：</p>
<pre><code class="language-ts"><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-3">main</span><span class="hl-1"> = </span><span class="hl-0">async</span><span class="hl-1"> (</span><span class="hl-5">req</span><span class="hl-1">: </span><span class="hl-7">HttpReq</span><span class="hl-1">) </span><span class="hl-0">=&gt;</span><span class="hl-1"> </span><span class="hl-3">createRes</span><span class="hl-1">();</span><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">timeMeasure</span><span class="hl-1"> = </span><span class="hl-3">createEffect</span><span class="hl-1">&lt;</span><span class="hl-0">typeof</span><span class="hl-1"> </span><span class="hl-5">main</span><span class="hl-1">&gt;(</span><br/><span class="hl-1">    </span><span class="hl-5">req</span><span class="hl-1"> </span><span class="hl-0">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">        </span><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">start</span><span class="hl-1"> = </span><span class="hl-0">new</span><span class="hl-1"> </span><span class="hl-7">Date</span><span class="hl-1">();</span><br/><span class="hl-1">        </span><span class="hl-8">return</span><span class="hl-1"> </span><span class="hl-5">res</span><span class="hl-1"> </span><span class="hl-0">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">            </span><span class="hl-5">console</span><span class="hl-1">.</span><span class="hl-3">log</span><span class="hl-1">(</span><span class="hl-4">`Use </span><span class="hl-0">${</span><span class="hl-0">new</span><span class="hl-6"> </span><span class="hl-7">Date</span><span class="hl-6">().</span><span class="hl-3">getTime</span><span class="hl-6">() </span><span class="hl-1">-</span><span class="hl-6"> </span><span class="hl-5">start</span><span class="hl-6">.</span><span class="hl-3">getTime</span><span class="hl-6">()</span><span class="hl-0">}</span><span class="hl-4">ms`</span><span class="hl-1">)</span><br/><span class="hl-1">        }</span><br/><span class="hl-1">    }</span><br/><span class="hl-1">)</span><br/><span class="hl-8">export</span><span class="hl-1"> </span><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">mainWithTimeMeasure</span><span class="hl-1"> = </span><span class="hl-3">timeMeasure</span><span class="hl-1">(</span><span class="hl-5">main</span><span class="hl-1">)</span>
</code></pre>

<a href="#函数包装" id="函数包装" style="color: inherit; text-decoration: none;">
  <h3>函数包装</h3>
</a>
<p>另一种情况下，我们可能会使用外部逻辑修改原始函数的输入输出，甚至改变参数的输入类型，例如：</p>
<pre><code class="language-ts"><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-3">main</span><span class="hl-1"> = </span><span class="hl-0">async</span><span class="hl-1"> (</span><span class="hl-5">req</span><span class="hl-1">: </span><span class="hl-7">HttpReq</span><span class="hl-1">, </span><span class="hl-5">body</span><span class="hl-1">: </span><span class="hl-7">Buffer</span><span class="hl-1">) </span><span class="hl-0">=&gt;</span><span class="hl-1"> </span><span class="hl-3">createRes</span><span class="hl-1">();</span><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">bodyParser</span><span class="hl-1"> = </span><span class="hl-3">createWrapper</span><span class="hl-1">&lt;(</span><span class="hl-5">req</span><span class="hl-1">: </span><span class="hl-7">HttpReq</span><span class="hl-1">) </span><span class="hl-0">=&gt;</span><span class="hl-1"> </span><span class="hl-7">AsyncResponse</span><span class="hl-1">, </span><span class="hl-0">typeof</span><span class="hl-1"> </span><span class="hl-5">main</span><span class="hl-1">&gt;(</span><br/><span class="hl-1">    </span><span class="hl-0">async</span><span class="hl-1"> </span><span class="hl-5">req</span><span class="hl-1"> </span><span class="hl-0">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">        </span><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">body</span><span class="hl-1"> = </span><span class="hl-8">await</span><span class="hl-1"> </span><span class="hl-3">rawBody</span><span class="hl-1">(</span><span class="hl-5">req</span><span class="hl-1">);</span><br/><span class="hl-1">        </span><span class="hl-8">return</span><span class="hl-1"> [[</span><span class="hl-5">req</span><span class="hl-1">, </span><span class="hl-5">body</span><span class="hl-1">], </span><span class="hl-5">res</span><span class="hl-1"> </span><span class="hl-0">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">            </span><span class="hl-5">res</span><span class="hl-1">.</span><span class="hl-3">setHeaders</span><span class="hl-1">([</span><span class="hl-4">&quot;Keep-Alive&quot;</span><span class="hl-1">, </span><span class="hl-4">&quot;timeout=10&quot;</span><span class="hl-1">]);</span><br/><span class="hl-1">            </span><span class="hl-8">return</span><span class="hl-1"> </span><span class="hl-5">res</span><br/><span class="hl-1">        }]</span><br/><span class="hl-1">    }</span><br/><span class="hl-1">)</span><br/><span class="hl-8">export</span><span class="hl-1"> </span><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">withBodyParser</span><span class="hl-1"> = </span><span class="hl-3">bodyParser</span><span class="hl-1">(</span><span class="hl-5">main</span><span class="hl-1">)</span>
</code></pre>
</div></div><div class="col-4 col-menu menu-sticky-wrap menu-highlight"><nav class="tsd-navigation primary"><ul><li class="current"><a href="modules.html">Exports</a></li></ul></nav><nav class="tsd-navigation secondary menu-sticky"><ul><li class="tsd-kind-interface"><a href="interfaces/ResponseProps.html" class="tsd-kind-icon">Response<wbr/>Props</a></li><li class="tsd-kind-type-alias"><a href="modules.html#ResponseBody" class="tsd-kind-icon">Response<wbr/>Body</a></li><li class="tsd-kind-type-alias"><a href="modules.html#AsyncResponse" class="tsd-kind-icon">Async<wbr/>Response</a></li><li class="tsd-kind-class"><a href="classes/Respond.html" class="tsd-kind-icon">Respond</a></li><li class="tsd-kind-function"><a href="modules.html#createRes" class="tsd-kind-icon">create<wbr/>Res</a></li><li class="tsd-kind-type-alias"><a href="modules.html#HeaderValue" class="tsd-kind-icon">Header<wbr/>Value</a></li><li class="tsd-kind-type-alias"><a href="modules.html#HeaderObject" class="tsd-kind-icon">Header<wbr/>Object</a></li><li class="tsd-kind-type-alias"><a href="modules.html#HeaderArray" class="tsd-kind-icon">Header<wbr/>Array</a></li><li class="tsd-kind-type-alias"><a href="modules.html#HeaderCollection" class="tsd-kind-icon">Header<wbr/>Collection</a></li><li class="tsd-kind-variable"><a href="modules.html#infoMessage" class="tsd-kind-icon">info<wbr/>Message</a></li><li class="tsd-kind-type-alias"><a href="modules.html#infoStatusCode" class="tsd-kind-icon">info<wbr/>Status<wbr/>Code</a></li><li class="tsd-kind-variable"><a href="modules.html#successMessage" class="tsd-kind-icon">success<wbr/>Message</a></li><li class="tsd-kind-type-alias"><a href="modules.html#successStatusCode" class="tsd-kind-icon">success<wbr/>Status<wbr/>Code</a></li><li class="tsd-kind-variable"><a href="modules.html#redirectMessage" class="tsd-kind-icon">redirect<wbr/>Message</a></li><li class="tsd-kind-type-alias"><a href="modules.html#redirectStatusCode" class="tsd-kind-icon">redirect<wbr/>Status<wbr/>Code</a></li><li class="tsd-kind-variable"><a href="modules.html#clientErrorMessage" class="tsd-kind-icon">client<wbr/>Error<wbr/>Message</a></li><li class="tsd-kind-type-alias"><a href="modules.html#clientErrorCode" class="tsd-kind-icon">client<wbr/>Error<wbr/>Code</a></li><li class="tsd-kind-variable"><a href="modules.html#serverErrorMessage" class="tsd-kind-icon">server<wbr/>Error<wbr/>Message</a></li><li class="tsd-kind-type-alias"><a href="modules.html#serverErrorCode" class="tsd-kind-icon">server<wbr/>Error<wbr/>Code</a></li><li class="tsd-kind-variable"><a href="modules.html#statusMessage" class="tsd-kind-icon">status<wbr/>Message</a></li><li class="tsd-kind-type-alias"><a href="modules.html#validHttpStatusCode" class="tsd-kind-icon">valid<wbr/>Http<wbr/>Status<wbr/>Code</a></li><li class="tsd-kind-type-alias"><a href="modules.html#HttpReq" class="tsd-kind-icon">Http<wbr/>Req</a></li><li class="tsd-kind-type-alias"><a href="modules.html#HttpRes" class="tsd-kind-icon">Http<wbr/>Res</a></li><li class="tsd-kind-type-alias"><a href="modules.html#ReqHandler" class="tsd-kind-icon">Req<wbr/>Handler</a></li><li class="tsd-kind-type-alias"><a href="modules.html#EntryPoint" class="tsd-kind-icon">Entry<wbr/>Point</a></li><li class="tsd-kind-function"><a href="modules.html#useRequest" class="tsd-kind-icon">use<wbr/>Request</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#useURL" class="tsd-kind-icon">useURL</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#createFlare" class="tsd-kind-icon">create<wbr/>Flare</a></li><li class="tsd-kind-function"><a href="modules.html#shimHTTP" class="tsd-kind-icon">shimHTTP</a></li><li class="tsd-kind-interface tsd-has-type-parameter"><a href="interfaces/ConditionInit.html" class="tsd-kind-icon">Condition<wbr/>Init</a></li><li class="tsd-kind-interface tsd-has-type-parameter"><a href="interfaces/Condition.html" class="tsd-kind-icon">Condition</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#condition" class="tsd-kind-icon">condition</a></li><li class="tsd-kind-type-alias tsd-has-type-parameter"><a href="modules.html#RouteHandler" class="tsd-kind-icon">Route<wbr/>Handler</a></li><li class="tsd-kind-type-alias tsd-has-type-parameter"><a href="modules.html#Route" class="tsd-kind-icon">Route</a></li><li class="tsd-kind-type-alias tsd-has-type-parameter"><a href="modules.html#ExtendRouteHandler" class="tsd-kind-icon">Extend<wbr/>Route<wbr/>Handler</a></li><li class="tsd-kind-type-alias tsd-has-type-parameter"><a href="modules.html#ExtendRoute" class="tsd-kind-icon">Extend<wbr/>Route</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#createRoute" class="tsd-kind-icon">create<wbr/>Route</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#createExtendRoute" class="tsd-kind-icon">create<wbr/>Extend<wbr/>Route</a></li><li class="tsd-kind-type-alias"><a href="modules.html#RouteChainInit" class="tsd-kind-icon">Route<wbr/>Chain<wbr/>Init</a></li><li class="tsd-kind-type-alias tsd-has-type-parameter"><a href="modules.html#RouteChainAdder" class="tsd-kind-icon">Route<wbr/>Chain<wbr/>Adder</a></li><li class="tsd-kind-type-alias tsd-has-type-parameter"><a href="modules.html#RouteChainFallback" class="tsd-kind-icon">Route<wbr/>Chain<wbr/>Fallback</a></li><li class="tsd-kind-type-alias tsd-has-type-parameter"><a href="modules.html#RouteChain" class="tsd-kind-icon">Route<wbr/>Chain</a></li><li class="tsd-kind-type-alias"><a href="modules.html#ExtendRouteChainInit" class="tsd-kind-icon">Extend<wbr/>Route<wbr/>Chain<wbr/>Init</a></li><li class="tsd-kind-type-alias tsd-has-type-parameter"><a href="modules.html#ExtendRouteChainAdder" class="tsd-kind-icon">Extend<wbr/>Route<wbr/>Chain<wbr/>Adder</a></li><li class="tsd-kind-type-alias tsd-has-type-parameter"><a href="modules.html#ExtendRouteChainFallback" class="tsd-kind-icon">Extend<wbr/>Route<wbr/>Chain<wbr/>Fallback</a></li><li class="tsd-kind-type-alias tsd-has-type-parameter"><a href="modules.html#ExtendRouteChain" class="tsd-kind-icon">Extend<wbr/>Route<wbr/>Chain</a></li><li class="tsd-kind-function"><a href="modules.html#createSwRt" class="tsd-kind-icon">create<wbr/>Sw<wbr/>Rt</a></li><li class="tsd-kind-function"><a href="modules.html#createExtendSwRt" class="tsd-kind-icon">create<wbr/>Extend<wbr/>Sw<wbr/>Rt</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#createSwitcher" class="tsd-kind-icon">create<wbr/>Switcher</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#createExtendSwitcher" class="tsd-kind-icon">create<wbr/>Extend<wbr/>Switcher</a></li><li class="tsd-kind-type-alias tsd-has-type-parameter"><a href="modules.html#ParamFlag" class="tsd-kind-icon">Param<wbr/>Flag</a></li><li class="tsd-kind-type-alias tsd-has-type-parameter"><a href="modules.html#RoutePattern" class="tsd-kind-icon">Route<wbr/>Pattern</a></li><li class="tsd-kind-type-alias tsd-has-type-parameter"><a href="modules.html#RouteParam" class="tsd-kind-icon">Route<wbr/>Param</a></li><li class="tsd-kind-type-alias tsd-has-type-parameter"><a href="modules.html#MaybePromise" class="tsd-kind-icon">Maybe<wbr/>Promise</a></li><li class="tsd-kind-type-alias"><a href="modules.html#EncodingType" class="tsd-kind-icon">Encoding<wbr/>Type</a></li><li class="tsd-kind-function"><a href="modules.html#contentType" class="tsd-kind-icon">content<wbr/>Type</a></li><li class="tsd-kind-function"><a href="modules.html#contentLength" class="tsd-kind-icon">content<wbr/>Length</a></li><li class="tsd-kind-function"><a href="modules.html#contentDisposition" class="tsd-kind-icon">content<wbr/>Disposition</a></li><li class="tsd-kind-function"><a href="modules.html#contentEncoding" class="tsd-kind-icon">content<wbr/>Encoding</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#contentLanguage" class="tsd-kind-icon">content<wbr/>Language</a></li><li class="tsd-kind-function"><a href="modules.html#serverHeader" class="tsd-kind-icon">server<wbr/>Header</a></li><li class="tsd-kind-function"><a href="modules.html#location" class="tsd-kind-icon">location</a></li><li class="tsd-kind-function"><a href="modules.html#acceptRanges" class="tsd-kind-icon">accept<wbr/>Ranges</a></li><li class="tsd-kind-interface tsd-has-type-parameter"><a href="interfaces/Composer.html" class="tsd-kind-icon">Composer</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#baseCompose" class="tsd-kind-icon">base<wbr/>Compose</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#composeFn" class="tsd-kind-icon">compose<wbr/>Fn</a></li><li class="tsd-kind-interface tsd-has-type-parameter"><a href="interfaces/Computation.html" class="tsd-kind-icon">Computation</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#compute" class="tsd-kind-icon">compute</a></li><li class="tsd-kind-interface tsd-has-type-parameter"><a href="interfaces/Lazy.html" class="tsd-kind-icon">Lazy</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#lazy" class="tsd-kind-icon">lazy</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#computeLazy" class="tsd-kind-icon">compute<wbr/>Lazy</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#createEffect" class="tsd-kind-icon">create<wbr/>Effect</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#addEffect" class="tsd-kind-icon">add<wbr/>Effect</a></li><li class="tsd-kind-type-alias"><a href="modules.html#Fn" class="tsd-kind-icon">Fn</a></li><li class="tsd-kind-type-alias"><a href="modules.html#AsyncFn" class="tsd-kind-icon">Async<wbr/>Fn</a></li><li class="tsd-kind-type-alias tsd-has-type-parameter"><a href="modules.html#BeforeHookArray" class="tsd-kind-icon">Before<wbr/>Hook<wbr/>Array</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#echo" class="tsd-kind-icon">echo</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#createWrapper" class="tsd-kind-icon">create<wbr/>Wrapper</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#addWrapper" class="tsd-kind-icon">add<wbr/>Wrapper</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#isVoid" class="tsd-kind-icon">is<wbr/>Void</a></li><li class="tsd-kind-interface"><a href="interfaces/HasToJSON.html" class="tsd-kind-icon">Has<wbr/>ToJSON</a></li><li class="tsd-kind-type-alias"><a href="modules.html#BasicJSONTypes" class="tsd-kind-icon">BasicJSONTypes</a></li><li class="tsd-kind-type-alias"><a href="modules.html#JsonObject" class="tsd-kind-icon">Json<wbr/>Object</a></li><li class="tsd-kind-type-alias"><a href="modules.html#JsonArray" class="tsd-kind-icon">Json<wbr/>Array</a></li><li class="tsd-kind-type-alias"><a href="modules.html#JsonType" class="tsd-kind-icon">Json<wbr/>Type</a></li><li class="tsd-kind-function"><a href="modules.html#resJson" class="tsd-kind-icon">res<wbr/>Json</a></li></ul></nav></div></div></div><footer class="with-border-bottom"><div class="container"><h2>Legend</h2><div class="tsd-legend-group"><ul class="tsd-legend"><li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li><li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li></ul><ul class="tsd-legend"><li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li><li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li></ul><ul class="tsd-legend"><li class="tsd-kind-property tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private property</span></li></ul><ul class="tsd-legend"><li class="tsd-kind-method tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static method</span></li></ul></div><h2>Settings</h2><p>Theme <select id="theme"><option value="os">OS</option><option value="light">Light</option><option value="dark">Dark</option></select></p></div></footer><div class="container tsd-generator"><p>Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p></div><div class="overlay"></div><script src="assets/main.js"></script></body></html>