<!DOCTYPE html><html class="default"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="IE=edge"/><title>Freesia - v0.10.4</title><meta name="description" content="Documentation for Freesia - v0.10.4"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="assets/style.css"/><link rel="stylesheet" href="assets/highlight.css"/><script async src="assets/search.js" id="search-script"></script></head><body><script>document.body.classList.add(localStorage.getItem("tsd-theme") || "os")</script><header><div class="tsd-page-toolbar"><div class="container"><div class="table-wrap"><div class="table-cell" id="tsd-search" data-base="."><div class="field"><label for="tsd-search-field" class="tsd-widget search no-caption">Search</label><input type="text" id="tsd-search-field"/></div><ul class="results"><li class="state loading">Preparing search index...</li><li class="state failure">The search index is not available</li></ul><a href="index.html" class="title">Freesia - v0.10.4</a></div><div class="table-cell" id="tsd-widgets"><div id="tsd-filter"><a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a><div class="tsd-filter-group"><div class="tsd-select" id="tsd-filter-visibility"><span class="tsd-select-label">All</span><ul class="tsd-select-list"><li data-value="public">Public</li><li data-value="protected">Public/Protected</li><li data-value="private" class="selected">All</li></ul></div> <input type="checkbox" id="tsd-filter-inherited" checked/><label class="tsd-widget" for="tsd-filter-inherited">Inherited</label><input type="checkbox" id="tsd-filter-externals" checked/><label class="tsd-widget" for="tsd-filter-externals">Externals</label></div></div><a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a></div></div></div></div><div class="tsd-page-title"><div class="container"><h1>Freesia - v0.10.4</h1></div></div></header><div class="container container-main"><div class="row"><div class="col-8 col-content"><div class="tsd-panel tsd-typography">
<a href="#freesia" id="freesia" style="color: inherit; text-decoration: none;">
  <h1>Freesia</h1>
</a>
<p>Freesia 是一个 Node.js 的 Web 服务器开发的 TypeScript 库。</p>

<a href="#安装" id="安装" style="color: inherit; text-decoration: none;">
  <h2>安装</h2>
</a>
<pre><code class="language-sh"><span class="hl-1">npm install freesia</span><br/><span class="hl-1">npm install -D typescript @types/node</span>
</code></pre>

<a href="#response--frequest" id="response--frequest" style="color: inherit; text-decoration: none;">
  <h2>response = f(request)</h2>
</a>
<p>受到 React 中<code>UI = f(state)</code>的启发，Freesia 库的核心观念是<code>response = f(request)</code>。当你使用 Freesia 库时，整个开发工作将围绕构建<code>f</code>函数展开。</p>
<p>一个最简单的<code>hello, world</code>程序对于 Freesia 而言应该是这样：</p>
<pre><code class="language-ts"><span class="hl-8">import</span><span class="hl-1"> { </span><span class="hl-5">createServer</span><span class="hl-1"> } </span><span class="hl-8">from</span><span class="hl-1"> </span><span class="hl-4">&quot;http&quot;</span><span class="hl-1">;</span><br/><span class="hl-8">import</span><span class="hl-1"> { </span><span class="hl-5">shimHTTP</span><span class="hl-1">, </span><span class="hl-5">createRes</span><span class="hl-1"> } </span><span class="hl-8">from</span><span class="hl-1"> </span><span class="hl-4">&quot;freesia&quot;</span><span class="hl-1">;</span><br/><span class="hl-3">createServer</span><span class="hl-1">(</span><span class="hl-3">shimHTTP</span><span class="hl-1">(</span><span class="hl-0">async</span><span class="hl-1"> (</span><span class="hl-5">req</span><span class="hl-1">) </span><span class="hl-0">=&gt;</span><span class="hl-1"> </span><span class="hl-3">createRes</span><span class="hl-1">(</span><span class="hl-4">&quot;hello, world&quot;</span><span class="hl-1">))).</span><span class="hl-3">listen</span><span class="hl-1">(</span><span class="hl-9">8000</span><span class="hl-1">);</span>
</code></pre>
<p>核心的逻辑是<code>async req =&gt; createRes(&quot;hello, world&quot;)</code>，接受一个 req 对象作为参数，返回一个 Response 对象，正如 React 中传入 props 而返回 JSX 一样。</p>

<a href="#响应" id="响应" style="color: inherit; text-decoration: none;">
  <h2>响应</h2>
</a>
<p>从最基础的 HTTP 传输而言，响应内容值得关心的一般分为 3 个部分：状态码、响应头和响应主体。一些情况下，可能出现自定义状态消息的需求。对于 Freesia 的主函数而言，它应该返回一个符合<code>ResponseProps</code>定义的对象（或者<code>Promise&lt;ResponseProps&gt;</code>），它应该包含上述四种内容。例如：</p>
<pre><code class="language-ts"><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">response</span><span class="hl-1"> = {</span><br/><span class="hl-1">    </span><span class="hl-5">statusCode:</span><span class="hl-1"> </span><span class="hl-9">200</span><span class="hl-1">, </span><span class="hl-10">// 一切有效的HTTP状态码</span><br/><span class="hl-1">    </span><span class="hl-5">statusMessage:</span><span class="hl-1"> </span><span class="hl-4">&quot;Ok&quot;</span><span class="hl-1">, </span><span class="hl-10">// 状态消息对HTTP/2是无效的，现代客户端有时也并不接受自定义状态消息</span><br/><span class="hl-1">    </span><span class="hl-5">body:</span><span class="hl-1"> </span><span class="hl-4">&quot;hello, world&quot;</span><span class="hl-1">, </span><span class="hl-10">// body可以是一个字符串，Buffer或者可读的Node.js流</span><br/><span class="hl-1">    </span><span class="hl-5">headers:</span><span class="hl-1"> { </span><span class="hl-4">&quot;Content-Type&quot;</span><span class="hl-5">:</span><span class="hl-1"> </span><span class="hl-4">&quot;text/plain; charset=UTF-8&quot;</span><span class="hl-1"> }, </span><span class="hl-10">// headers的key是string，value是string|string[]|number</span><br/><span class="hl-1">};</span>
</code></pre>
<p>除去手动声明之外，Freesia 还提供了一个<code>Respond</code>类来帮助创建响应对象。</p>

<a href="#respond-类" id="respond-类" style="color: inherit; text-decoration: none;">
  <h3>Respond 类</h3>
</a>
<p>创建<code>Respond</code>对象的方法有如下三种：</p>
<pre><code class="language-ts"><span class="hl-8">import</span><span class="hl-1"> { </span><span class="hl-5">Respond</span><span class="hl-1">, </span><span class="hl-5">createRes</span><span class="hl-1"> } </span><span class="hl-8">from</span><span class="hl-1"> </span><span class="hl-4">&quot;freesia&quot;</span><span class="hl-1">;</span><br/><span class="hl-10">// new Respond</span><br/><span class="hl-0">new</span><span class="hl-1"> </span><span class="hl-3">Respond</span><span class="hl-1">()</span><br/><span class="hl-1">    .</span><span class="hl-3">setBody</span><span class="hl-1">(</span><span class="hl-4">&quot;hello, world&quot;</span><span class="hl-1">)</span><br/><span class="hl-1">    .</span><span class="hl-3">setHeaders</span><span class="hl-1">([</span><span class="hl-4">&quot;Content-Type&quot;</span><span class="hl-1">, </span><span class="hl-4">&quot;text/plain; charset=UTF-8&quot;</span><span class="hl-1">])</span><br/><span class="hl-1">    .</span><span class="hl-3">setHeaders</span><span class="hl-1">([</span><span class="hl-4">&quot;Content-Length&quot;</span><span class="hl-1">, </span><span class="hl-9">12</span><span class="hl-1">]);</span><br/><span class="hl-5">Respond</span><span class="hl-1">.</span><span class="hl-3">create</span><span class="hl-1">(</span><span class="hl-4">&quot;hello, world&quot;</span><span class="hl-1">, {</span><br/><span class="hl-1">    </span><span class="hl-4">&quot;Content-Type&quot;</span><span class="hl-5">:</span><span class="hl-1"> </span><span class="hl-4">&quot;text/plain; charset=UTF-8&quot;</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-4">&quot;Content-Length&quot;</span><span class="hl-5">:</span><span class="hl-1"> </span><span class="hl-9">12</span><span class="hl-1">,</span><br/><span class="hl-1">});</span><br/><span class="hl-3">createRes</span><span class="hl-1">(</span><span class="hl-4">&quot;hello, world&quot;</span><span class="hl-1">, {</span><br/><span class="hl-1">    </span><span class="hl-4">&quot;Content-Type&quot;</span><span class="hl-5">:</span><span class="hl-1"> </span><span class="hl-4">&quot;text/plain; charset=UTF-8&quot;</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-4">&quot;Content-Length&quot;</span><span class="hl-5">:</span><span class="hl-1"> </span><span class="hl-9">12</span><span class="hl-1">,</span><br/><span class="hl-1">});</span>
</code></pre>
<p>其中，<code>createRes</code>是<code>Respond.create</code>的别名，这两个方法比<code>new Respond()</code>更加简便，提供了多种重载用于一次性建立一个响应对象，参考<a href="https://qihexiang.github.io/freesia/classes/Respond.html#create">API 文档</a>。</p>
<p><code>Respond</code>对象包含如下方法：</p>
<ul>
<li>setStatusCode</li>
<li>setStatusMessage</li>
<li>setBody</li>
<li>setHeaders</li>
</ul>
<p>用于设置对象对应的属性，其中前三种方法每次调用会替代掉前一次调用的结果，而<code>setHeaders</code>方法则会在每次调用时将新的响应头合并到之间的结果中，例如上面调用中的两次<code>setHeaders</code>设置的响应头都是有效的。此外，setHeaders 还支持多种格式的输入，请参考<a href="https://qihexiang.github.io/freesia/classes/Respond.html#setHeaders">API 文档</a>。</p>
<p>Freesia 提供了一些函数来配合<code>setHeaders</code>方法的使用，例如：</p>
<pre><code class="language-ts"><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">message</span><span class="hl-1"> = </span><span class="hl-4">&quot;hello, world</span><span class="hl-11">\n</span><span class="hl-4">&quot;</span><span class="hl-1">;</span><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">response</span><span class="hl-1"> = </span><span class="hl-3">createRes</span><span class="hl-1">(</span><span class="hl-9">200</span><span class="hl-1">, </span><span class="hl-5">message</span><span class="hl-1">).</span><span class="hl-3">setHeaders</span><span class="hl-1">(</span><br/><span class="hl-1">    </span><span class="hl-3">contentType</span><span class="hl-1">(</span><span class="hl-4">&quot;txt&quot;</span><span class="hl-1">, </span><span class="hl-4">&quot;UTF-8&quot;</span><span class="hl-1">),</span><br/><span class="hl-1">    </span><span class="hl-3">contentLength</span><span class="hl-1">(</span><span class="hl-5">message</span><span class="hl-1">),</span><br/><span class="hl-1">    </span><span class="hl-3">contentDisposition</span><span class="hl-1">(</span><span class="hl-0">true</span><span class="hl-1">, </span><span class="hl-4">&quot;helloWorld.txt&quot;</span><span class="hl-1">)</span><br/><span class="hl-1">);</span>
</code></pre>

<a href="#路由" id="路由" style="color: inherit; text-decoration: none;">
  <h2>路由</h2>
</a>
<p>由于函数式的设计，这个库并不包含像 express 那样的<code>app.get(pattern, handler)</code>风格的路由，而是通过工具函数来实现请求路径的区分的。</p>

<a href="#路由（route）" id="路由（route）" style="color: inherit; text-decoration: none;">
  <h3>路由（Route）</h3>
</a>
<p>路由在 Freesia 中的概念是，当用户访问的路径符合某一个规则的时候，则执行对应的函数，并获得函数的返回值。要创建一个路由，使用<code>createRoute</code>函数来实现。</p>
<p><code>createRoute</code>中可以传入两个参数，第一个是路由匹配模式<code>pattern</code>，格式像这样：<code>/user/&lt;username&gt;/&lt;age&gt;/</code>，这样，就可以匹配到类似于<code>/user/freesia/16/</code>这样的路径。</p>
<p>表明路径参数的形式有三种：</p>
<ul>
<li><code>&lt;T&gt;</code>：非贪婪模式，匹配任意字符出现至少一次。</li>
<li><code>&lt;[T]&gt;</code>：贪婪模式，匹配任意字符至少出现一次。</li>
<li><code>[T]</code>：贪婪模式，匹配任意字符，也可以没有字符。</li>
</ul>
<p>可以观看这个例子中，对<code>filepath</code>的捕获情况来理解：</p>
<table>
<thead>
<tr>
<th>模式/路径</th>
<th><code>/user/hx/docs/index.md</code></th>
<th><code>/user/hx/docs/index.md/</code></th>
<th><code>/user/hx/</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>/user/&lt;name&gt;/&lt;filepath&gt;/</code></td>
<td><code>null</code></td>
<td><code>null</code></td>
<td><code>null</code></td>
</tr>
<tr>
<td><code>/user/&lt;name&gt;/&lt;filepath&gt;</code></td>
<td><code>&quot;docs/index.md&quot;</code></td>
<td><code>&quot;docs/index.md/&quot;</code></td>
<td><code>null</code></td>
</tr>
<tr>
<td><code>/user/&lt;name&gt;/&lt;[filepath]&gt;/</code></td>
<td><code>null</code></td>
<td><code>&quot;doc/index.md&quot;</code></td>
<td><code>null</code></td>
</tr>
<tr>
<td><code>/user/&lt;name&gt;/[filepath]</code></td>
<td><code>&quot;docs/index.md&quot;</code></td>
<td><code>&quot;docs/index.md/&quot;</code></td>
<td><code>&quot;&quot;</code></td>
</tr>
</tbody></table>
<p>另一个参数自然是对应的函数<code>handler</code>，这个函数的参数是根据<code>pattern</code>推导出的路由匹配参数<code>params</code>，例如上面的例子中，推导出的参数类型为<code>{name: string, filepath: string}</code>，所有的路由参数类型都是<code>string</code>，开发者应该根据实际的情况进行检查和类型转换。</p>
<p>下面是一个示例：</p>
<pre><code class="language-js"><span class="hl-8">import</span><span class="hl-1"> { </span><span class="hl-5">createRoute</span><span class="hl-1"> } </span><span class="hl-8">from</span><span class="hl-1"> </span><span class="hl-4">&quot;freesia&quot;</span><br/><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">route</span><span class="hl-1"> = </span><span class="hl-3">createRoute</span><span class="hl-1">(</span><span class="hl-4">&#39;/user/&lt;username&gt;/&lt;filepath&gt;&#39;</span><span class="hl-1">, </span><span class="hl-3">async</span><span class="hl-1"> ({</span><span class="hl-5">username</span><span class="hl-1">, </span><span class="hl-5">filepath</span><span class="hl-1">})</span><br/><span class="hl-1">    </span><span class="hl-0">=&gt;</span><span class="hl-1"> </span><span class="hl-7">JSON</span><span class="hl-1">.</span><span class="hl-3">stringify</span><span class="hl-1">(</span><span class="hl-8">await</span><span class="hl-1"> </span><span class="hl-3">readDir</span><span class="hl-1">(</span><span class="hl-5">username</span><span class="hl-1">, </span><span class="hl-5">filepath</span><span class="hl-1">)))</span><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">result</span><span class="hl-1"> = </span><span class="hl-8">await</span><span class="hl-1"> </span><span class="hl-3">route</span><span class="hl-1">(</span><span class="hl-5">url</span><span class="hl-1">)</span>
</code></pre>

<a href="#交换机（switcher）" id="交换机（switcher）" style="color: inherit; text-decoration: none;">
  <h3>交换机（Switcher）</h3>
</a>
<p>每个 Route 只是一条路径，实际上需要使用多条路径进行依次匹配。使用交换机（Switcher）实现该功能。例如有路由<code>route1</code>-<code>route6</code>，他们的<code>handler</code>拥有相同的返回类型，则可以聚合在一起。</p>
<blockquote>
<p>返回类型不同的平级路由，使用联合类型作为 Switcher 的泛型类型。</p>
</blockquote>
<p>方式如下：</p>
<pre><code class="language-js"><span class="hl-8">import</span><span class="hl-1"> { </span><span class="hl-5">createSwitcher</span><span class="hl-1"> } </span><span class="hl-8">from</span><span class="hl-1"> </span><span class="hl-4">&quot;freesia&quot;</span><span class="hl-1">;</span><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">switcher</span><span class="hl-1"> = </span><span class="hl-3">createSwitcher</span><span class="hl-1">(</span><span class="hl-5">route1</span><span class="hl-1">, </span><span class="hl-5">route2</span><span class="hl-1">, </span><span class="hl-5">route3</span><span class="hl-1">, </span><span class="hl-5">route4</span><span class="hl-1">, </span><span class="hl-5">route5</span><span class="hl-1">, </span><span class="hl-5">route6</span><span class="hl-1">);</span><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">result</span><span class="hl-1"> = </span><span class="hl-3">switcher</span><span class="hl-1">(</span><span class="hl-5">url</span><span class="hl-1">);</span>
</code></pre>
<p>Switcher 最终得到的函数和 Route 实际上是一样的，因此可以逐级将多个 Switcher 也聚合起来。</p>
<blockquote>
<p>注意，由于<code>switcher</code>的实现使用了<code>??</code>运算符（判断匹配失败的依据是路由返回<code>null</code>），因此当你需要返回<code>null</code>或<code>undefined</code>时，必须将其包裹起来，例如<code>{ value: null }</code>。</p>
<p>这个问题在你有多个可以匹配同一个路径的模式时尤为重要，例如下列两种模式：</p>
<ul>
<li><code>/api/user/avatar</code></li>
<li><code>/api/user/&lt;otherInfo&gt;</code></li>
</ul>
<p>都可以匹配到<code>/api/user/avatar</code>，如果第一个路由都返回<code>undefined</code>，则这两个路由回调都会被执行，尽管返回值是<code>undefined</code>，但函数中的副作用依然会发生。</p>
</blockquote>

<a href="#额外参数" id="额外参数" style="color: inherit; text-decoration: none;">
  <h3>额外参数</h3>
</a>
<p>在实际使用中，<code>handler</code>往往还需要其他参数的输入，你可以这样来获得额外参数：</p>
<pre><code class="language-ts"><span class="hl-8">import</span><span class="hl-1"> </span><span class="hl-5">apiRouteHandler</span><span class="hl-1"> </span><span class="hl-8">from</span><span class="hl-1"> </span><span class="hl-4">&quot;./controller/api&quot;</span><span class="hl-1">;</span><br/><span class="hl-8">import</span><span class="hl-1"> </span><span class="hl-5">DB</span><span class="hl-1"> </span><span class="hl-8">from</span><span class="hl-1"> </span><span class="hl-4">&quot;./data/IO&quot;</span><span class="hl-1">;</span><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">db</span><span class="hl-1"> = </span><span class="hl-0">new</span><span class="hl-1"> </span><span class="hl-3">DB</span><span class="hl-1">();</span><br/><br/><span class="hl-0">function</span><span class="hl-1"> </span><span class="hl-3">main</span><span class="hl-1">(</span><span class="hl-5">req</span><span class="hl-1">: </span><span class="hl-7">Request</span><span class="hl-1">) {</span><br/><span class="hl-1">    </span><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">result</span><span class="hl-1"> = </span><span class="hl-8">await</span><span class="hl-1"> </span><span class="hl-3">createRoute</span><span class="hl-1">(</span><span class="hl-4">&quot;/api/&lt;options&gt;&quot;</span><span class="hl-1">, ({ </span><span class="hl-5">options</span><span class="hl-1"> }) </span><span class="hl-0">=&gt;</span><br/><span class="hl-1">        </span><span class="hl-3">apiRouteHandler</span><span class="hl-1">(</span><span class="hl-5">options</span><span class="hl-1">, { </span><span class="hl-5">req</span><span class="hl-1">, </span><span class="hl-5">db</span><span class="hl-1"> })</span><br/><span class="hl-1">    )(</span><span class="hl-5">req</span><span class="hl-1">.</span><span class="hl-5">url</span><span class="hl-1">);</span><br/><span class="hl-1">    </span><span class="hl-8">return</span><span class="hl-1"> </span><span class="hl-5">result</span><span class="hl-1">;</span><br/><span class="hl-1">}</span>
</code></pre>
<p>但如果我们想将路径和控制器绑定之后再接收参数的话，就无法做到了。因此，本库中提供了额外的函数：<code>createRouteX</code>。它的使用与<code>createRoute</code>基本相同，差异在于它的<code>handler</code>可以接受一个额外的自定义类型参数；返回的路由匹配时也可以接收一个对应的参数。例如上面的例子会变成：</p>
<pre><code class="language-ts"><span class="hl-10">// controller/api.ts</span><br/><span class="hl-8">export</span><span class="hl-1"> </span><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">apiRoute</span><span class="hl-1"> = </span><span class="hl-3">createRouteX</span><span class="hl-1">(</span><span class="hl-4">&#39;/api/&lt;options&gt;&#39;</span><span class="hl-1">, ({</span><span class="hl-5">options</span><span class="hl-1">}, {</span><span class="hl-5">req</span><span class="hl-1">: </span><span class="hl-5">Request</span><span class="hl-1">, </span><span class="hl-5">db</span><span class="hl-1">: </span><span class="hl-5">DB</span><span class="hl-1">}) </span><span class="hl-0">=&gt;</span><span class="hl-1"> {...})</span><br/><br/><span class="hl-10">// main.ts</span><br/><span class="hl-8">import</span><span class="hl-1"> { </span><span class="hl-5">apiRoute</span><span class="hl-1"> } </span><span class="hl-8">from</span><span class="hl-1"> </span><span class="hl-4">&quot;./controller/api&quot;</span><br/><span class="hl-8">import</span><span class="hl-1"> </span><span class="hl-5">DB</span><span class="hl-1"> </span><span class="hl-8">from</span><span class="hl-1"> </span><span class="hl-4">&quot;./data/IO&quot;</span><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">db</span><span class="hl-1"> = </span><span class="hl-0">new</span><span class="hl-1"> </span><span class="hl-3">DB</span><span class="hl-1">();</span><br/><br/><span class="hl-0">function</span><span class="hl-1"> </span><span class="hl-3">main</span><span class="hl-1">(</span><span class="hl-5">req</span><span class="hl-1">: </span><span class="hl-7">Request</span><span class="hl-1">) {</span><br/><span class="hl-1">    </span><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">route</span><span class="hl-1"> = </span><span class="hl-8">await</span><span class="hl-1"> </span><span class="hl-3">apiRoute</span><span class="hl-1">(</span><span class="hl-5">req</span><span class="hl-1">.</span><span class="hl-5">url</span><span class="hl-1">, {</span><span class="hl-5">req</span><span class="hl-1">, </span><span class="hl-5">db</span><span class="hl-1">})</span><br/><span class="hl-1">    </span><span class="hl-8">return</span><span class="hl-1"> </span><span class="hl-5">result</span><br/><span class="hl-1">}</span>
</code></pre>
<p>若有多个这样的扩展路由进行聚合时，可以使用<code>createSwitcherX</code>来创建交换机。</p>

<a href="#同时创建路由和交换机" id="同时创建路由和交换机" style="color: inherit; text-decoration: none;">
  <h4>同时创建路由和交换机</h4>
</a>
<p>利用<code>createRoute</code>和<code>createSwitcher</code>，我们可以在分离的多个地方对路由规则进行定义，但与此同时，也会有人更倾向与将路径匹配模式集中定义于一处，此时重复使用<code>createRoute</code>和<code>createSwitcher</code>就显得十分麻烦。Freesia 提供了一个额外的函数<code>createSwRt</code>来实现这个功能，他提供一个链试调用来创建一个交换机及其对应的路由。</p>
<p>例子如下，有若干已经定义好的<code>handler</code>，它们返回的值类型相互匹配（例如<code>Promise&lt;ResponseProps&gt;</code>）。</p>
<pre><code class="language-js"><span class="hl-8">import</span><span class="hl-1"> { </span><span class="hl-5">createSwRt</span><span class="hl-1"> } </span><span class="hl-8">from</span><span class="hl-1"> </span><span class="hl-4">&quot;freesia&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-0">async</span><span class="hl-1"> </span><span class="hl-0">function</span><span class="hl-1"> </span><span class="hl-3">main</span><span class="hl-1">(</span><span class="hl-5">req</span><span class="hl-1">) {</span><br/><span class="hl-1">    </span><span class="hl-0">const</span><span class="hl-1"> { </span><span class="hl-2">switcher</span><span class="hl-1"> } = </span><span class="hl-3">createSwRt</span><span class="hl-1">()</span><br/><span class="hl-1">        .</span><span class="hl-3">route</span><span class="hl-1">(</span><span class="hl-4">&quot;/user/&lt;username&gt;/&lt;rest&gt;&quot;</span><span class="hl-1">, </span><span class="hl-5">infoHandler</span><span class="hl-1">)</span><br/><span class="hl-1">        .</span><span class="hl-3">route</span><span class="hl-1">(</span><span class="hl-4">&quot;/view/&lt;rest&gt;&quot;</span><span class="hl-1">, </span><span class="hl-5">viewHandler</span><span class="hl-1">)</span><br/><span class="hl-1">        .</span><span class="hl-3">route</span><span class="hl-1">(</span><span class="hl-4">&quot;/d/&lt;username&gt;/&lt;filepath&gt;&quot;</span><span class="hl-1">, </span><span class="hl-5">downloadHandler</span><span class="hl-1">)</span><br/><span class="hl-1">        .</span><span class="hl-3">route</span><span class="hl-1">(</span><span class="hl-4">&quot;/b/&lt;username&gt;/&lt;[filepath]&gt;/&quot;</span><span class="hl-1">, </span><span class="hl-5">browseHandler</span><span class="hl-1">)</span><br/><span class="hl-1">        .</span><span class="hl-3">fallback</span><span class="hl-1">(</span><span class="hl-0">async</span><span class="hl-1"> (</span><span class="hl-5">url</span><span class="hl-1">) </span><span class="hl-0">=&gt;</span><span class="hl-1"> </span><span class="hl-3">createRes</span><span class="hl-1">(</span><span class="hl-9">404</span><span class="hl-1">, </span><span class="hl-4">`No route matched </span><span class="hl-0">${</span><span class="hl-5">url</span><span class="hl-0">}</span><span class="hl-4">`</span><span class="hl-1">));</span><br/><span class="hl-1">    </span><span class="hl-8">return</span><span class="hl-1"> </span><span class="hl-3">switcher</span><span class="hl-1">(</span><span class="hl-5">url</span><span class="hl-1">);</span><br/><span class="hl-1">}</span>
</code></pre>
<p><code>route</code>和<code>fallback</code>函数会检查<code>handler</code>的返回类型是否一致，一致性的依据是第一个被调用的<code>route</code>方法的传入参数，如果要手动指定返回类型，例如有的<code>handler</code>返回异步结果，有的返回同步结果，则应该在第一次调用<code>route</code>时明确泛型类型，<code>.route&lt;Promise&lt;ResponseProps&gt;&gt;|ResponseProps&gt;</code>。后续的<code>route</code>函数和第一个<code>route</code>并不是同一个函数，他们没有泛型参数。</p>
<blockquote>
<p>自 0.8.20 版本起，你可以使用<code>createSwRt.route</code>来代替<code>createSwRt().route</code>，<code>createSwRt</code>保留后者仅为了和之前版本的代码兼容。</p>
</blockquote>
<blockquote>
<p>请务必不要通过导出<code>createSwRt</code>的执行结果来在多个文件中注册路由：<br>第一次返回的<code>route</code>方法实际上会返回一个全新的对象，多次调用并不能将多个路由注册到一个交换机上，而是产生多个交换机；<br>之后的<code>route</code>方法可以在多处调用并注册路由到同一个交换机，但是注册的顺序取决于模块导入导出的逻辑，这会使得路由顺序和你设想的不一致；<br><code>fallback</code>方法并不会更新闭包，除非你使用它的返回值，否则这个注册是无效的。</p>
</blockquote>
<p>每次链式调用中的<code>route</code>函数和<code>createRoute</code>函数参数类型一致，返回中解析出的<code>switcher</code>和<code>createSwitcher</code>的类型是一致的。</p>
<p>另外，提供了一个<code>createSwRtX</code>函数，来创建接受额外参数的路由和交换机，使用方法基本一致。</p>

<a href="#方法限制" id="方法限制" style="color: inherit; text-decoration: none;">
  <h3>方法限制</h3>
</a>
<p>上面介绍的路由并不对请求的请求方法进行检查，而在<code>handler</code>内部检查有时会变的麻烦，因此提供了<code>allowMethods</code>函数来解决这个问题（对于扩展路由，使用<code>allowMethodsX</code>代替）。</p>
<pre><code class="language-ts"><span class="hl-10">// 这个路由仅对GET方法有效，其他方法请求会返回null</span><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">rt</span><span class="hl-1"> = </span><span class="hl-3">createRoute</span><span class="hl-1">(</span><br/><span class="hl-1">    </span><span class="hl-4">&quot;/hello/&lt;username&gt;/&quot;</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-3">allowMethods</span><span class="hl-1">(</span><span class="hl-5">helloWorldHandler</span><span class="hl-1">, [</span><span class="hl-4">&quot;GET&quot;</span><span class="hl-1">])</span><br/><span class="hl-1">);</span>
</code></pre>
<p><code>allowMethods</code>的地一个参数是原始的路由处理器，第二个参数是一个数组，将允许的请求方法放入其中。他将原始处理函数包装成一个可能返回 null 的形式。</p>
<p>此外，提供了该函数的封装：</p>
<ul>
<li>All 允许所有方法</li>
<li>Get 允许 GET 方法</li>
<li>Head 允许 HEAD 方法</li>
<li>Post 允许 POST 方法</li>
<li>...</li>
<li>命名的特征是方法名称的大写首字母形式</li>
<li>对于扩展路由，在末尾加上 X</li>
</ul>

<a href="#简单匹配（condition）" id="简单匹配（condition）" style="color: inherit; text-decoration: none;">
  <h3>简单匹配（Condition）</h3>
</a>
<p>上述的路由匹配模式只能支持 URL 的路径匹配，但实际上我们还会根据一些具体的情况，例如请求的方法、可枚举的具体路径参数等进行请求分流，这些情况一般需要精确匹配字符串。这使用上面的函数并不容易实现，或者显得更加麻烦，因此提供了一个<code>condition</code>函数，以链试调用的方式来实现类似与 switch 语法的功能，可以看作是一个带有返回值的 switch 块。</p>
<pre><code class="language-js"><span class="hl-8">import</span><span class="hl-1"> { </span><span class="hl-5">condition</span><span class="hl-1"> } </span><span class="hl-8">from</span><span class="hl-1"> </span><span class="hl-4">&quot;freesia&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">result</span><span class="hl-1"> = </span><span class="hl-3">condition</span><span class="hl-1">(</span><span class="hl-5">req</span><span class="hl-1">.</span><span class="hl-5">method</span><span class="hl-1">)</span><br/><span class="hl-1">    .</span><span class="hl-3">match</span><span class="hl-1">(</span><span class="hl-4">&quot;GET&quot;</span><span class="hl-1">, () </span><span class="hl-0">=&gt;</span><span class="hl-1"> </span><span class="hl-3">getSw</span><span class="hl-1">(</span><span class="hl-5">req</span><span class="hl-1">.</span><span class="hl-5">url</span><span class="hl-1">))</span><br/><span class="hl-1">    .</span><span class="hl-3">match</span><span class="hl-1">([</span><span class="hl-4">&quot;POST&quot;</span><span class="hl-1">, </span><span class="hl-4">&quot;PUT&quot;</span><span class="hl-1">], () </span><span class="hl-0">=&gt;</span><span class="hl-1"> </span><span class="hl-3">uploadSw</span><span class="hl-1">(</span><span class="hl-5">req</span><span class="hl-1">.</span><span class="hl-5">url</span><span class="hl-1">, </span><span class="hl-5">req</span><span class="hl-1">))</span><br/><span class="hl-1">    .</span><span class="hl-3">match</span><span class="hl-1">(</span><span class="hl-12">/</span><span class="hl-13">^</span><span class="hl-14">(</span><span class="hl-12">OPTION</span><span class="hl-13">|</span><span class="hl-12">TRACE</span><span class="hl-14">)</span><span class="hl-13">$</span><span class="hl-12">/</span><span class="hl-1">, (</span><span class="hl-5">method</span><span class="hl-1">) </span><span class="hl-0">=&gt;</span><span class="hl-1"> </span><span class="hl-3">debugSw</span><span class="hl-1">(</span><span class="hl-5">req</span><span class="hl-1">.</span><span class="hl-5">url</span><span class="hl-1">, </span><span class="hl-5">method</span><span class="hl-1">))</span><br/><span class="hl-1">    .</span><span class="hl-3">getValue</span><span class="hl-1">();</span>
</code></pre>
<p>例如，这个例子分流的依据是<code>req.method</code>，我们将<code>GET</code>请求分为一组，<code>POST</code>和<code>PUT</code>请求分为一组。调用链中，<code>match</code>的一个参数是字符串或字符串数组，当字符串和分流依据相等，或数组中存在匹配的字符串时，或给定的正则表达式与分流依据匹配时，会执行后续的<code>handler</code>，所有注册的<code>handler</code>应该有相同的返回类型或符合<code>condition&lt;T&gt;</code>描述的泛型。解构出的<code>result</code>是<code>handler</code>的返回值。</p>
<p>获得返回值有两种方法：<code>getValue</code>和<code>withDefault</code>，后者接受一个回调函数，来根据输入的值返回一个值。</p>

<a href="#魔法函数" id="魔法函数" style="color: inherit; text-decoration: none;">
  <h2>魔法函数</h2>
</a>
<p>魔法函数是一组依靠 Node.js 的<code>async_hooks</code>模块实现的函数，它们可以让你在调用链上的任意函数中获得之前过程中的到的值，而不必经过参数传递。</p>

<a href="#userequest" id="userequest" style="color: inherit; text-decoration: none;">
  <h3>useRequest</h3>
</a>
<p>当一个请求进入时，Node.js 会调用我们编写的主函数来处理这个请求，主函数可以接受到调用时传入的<code>req</code>参数。但有时我们会在一个极深的调用中使用他，例如：</p>
<p>main（接受到<code>req</code>参数） -&gt; fileOperateSwitcher -&gt; uploadHandler -&gt; privillegeChecker -&gt; securityChecker -&gt; uploadService（真正使用<code>req</code>的地方）</p>
<p>在这个调用中，如果没有<code>useRequest</code>函数，我们需要在每个函数中都传第一次<code>req</code>参数，这是非常麻烦的。使用<code>useRequest</code>函数，我们可以不传递<code>req</code>，而是直接在<code>uploadService</code>中使用：</p>
<pre><code class="language-ts"><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">req</span><span class="hl-1"> = </span><span class="hl-3">useRequest</span><span class="hl-1">();</span>
</code></pre>
<p>需要注意的是，<code>req</code>作为一个流在调用链上不能被接收两次，例如你使用<code>getRawBody</code>在<code>securityChecker</code>中完全接收之后，就不能再在<code>uploadService</code>中接收它了。</p>

<a href="#useurl" id="useurl" style="color: inherit; text-decoration: none;">
  <h3>useURL</h3>
</a>
<p><code>useURL</code>函数可以在<code>shimHTTP</code>的回调函数的任意层次调用中获得这个请求的路径信息，使用方法为：</p>
<pre><code class="language-ts"><span class="hl-3">useURL</span><span class="hl-1">(); </span><span class="hl-10">// 返回host（主机名）、path（访问路径）、query（搜索参数的searchParams），method（请求方法）</span><br/><span class="hl-3">useURL</span><span class="hl-1">(</span><span class="hl-4">&quot;method&quot;</span><span class="hl-1">); </span><span class="hl-10">// 返回方法</span><br/><span class="hl-3">useURL</span><span class="hl-1">(</span><span class="hl-4">&quot;host&quot;</span><span class="hl-1">); </span><span class="hl-10">// 返回host</span><br/><span class="hl-3">useURL</span><span class="hl-1">(</span><span class="hl-4">&quot;path&quot;</span><span class="hl-1">); </span><span class="hl-10">// 返回path</span><br/><span class="hl-3">useURL</span><span class="hl-1">(</span><span class="hl-4">&quot;query&quot;</span><span class="hl-1">); </span><span class="hl-10">// 返回query</span><br/><span class="hl-3">useURL</span><span class="hl-1">(</span><span class="hl-5">router</span><span class="hl-1">); </span><span class="hl-10">// Route&lt;T&gt;的路由，返回路由匹配结果。</span>
</code></pre>

<a href="#createflare" id="createflare" style="color: inherit; text-decoration: none;">
  <h3>createFlare</h3>
</a>
<p>除了在调用链上使用<code>req</code>或<code>url</code>信息，你还可以传递在调用过程中产生的任何值，使用<code>createFlare</code>函数来做到。</p>
<p>Freesia 提供了类似 React 上下文的功能（和请求绑定）。用<code>createFlare</code>函数来创建闪光弹，</p>
<p>它可以接受 0 或 1 个参数，若有参数，是一个对象，包含两项属性：</p>
<ul>
<li><code>mutable</code>：若为<code>true</code>，则观测得到的值不是只读的，如果你要使用闪光弹传递一个需要变化的 ORM 对象，它应该设置为 true；</li>
<li><code>reassign</code>：若为<code>true</code>，可以多次使用 light 函数重新给闪光弹赋值，一般没有理由这么做。</li>
<li>不输入参数时，上述属性默认为<code>false</code></li>
</ul>
<p>它返回三个函数：</p>
<ul>
<li><code>assign</code>：赋值到 flare，这个函数调用之后，要被传递的值就可以通过<code>observe</code>函数访问了；</li>
<li><code>observe</code>：观测 flare，执行这个函数可以得到要传递的值，它必须在<code>assign</code>函数之后调用；</li>
<li><code>drop</code>：舍弃 flare，执行这个函数之后，<code>observe</code>将不能再被使用</li>
</ul>
<blockquote>
<p>这三个函数是通过数组返回的，你可以给他们取任意需要的名字。</p>
</blockquote>
<pre><code class="language-ts"><span class="hl-10">// 调用次序为：main -&gt; fileRoute -&gt; uploadRoute -&gt; uploadHandler -&gt; uploadService</span><br/><span class="hl-10">// 我们不想逐层传递request对像来获得上传的body，我们在main函数获得body后，将其用</span><br/><span class="hl-10">// main.ts</span><br/><span class="hl-8">export</span><span class="hl-1"> </span><span class="hl-0">const</span><span class="hl-1"> [</span><span class="hl-2">assign</span><span class="hl-1">, </span><span class="hl-2">observe</span><span class="hl-1">, </span><span class="hl-2">drop</span><span class="hl-1">] = </span><span class="hl-3">createFlare</span><span class="hl-1">&lt;</span><span class="hl-7">Buffer</span><span class="hl-1">&gt;()</span><br/><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-3">main</span><span class="hl-1"> = </span><span class="hl-0">async</span><span class="hl-1"> </span><span class="hl-5">req</span><span class="hl-1"> </span><span class="hl-0">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">body</span><span class="hl-1"> = </span><span class="hl-8">await</span><span class="hl-1"> </span><span class="hl-3">getRawBody</span><span class="hl-1">(</span><span class="hl-5">req</span><span class="hl-1">);</span><br/><span class="hl-1">    </span><span class="hl-3">assign</span><span class="hl-1">(</span><span class="hl-5">body</span><span class="hl-1">); </span><span class="hl-10">// 从此向下的调用可以通过observe函数访问body</span><br/><span class="hl-1">    ...</span><br/><span class="hl-1">    </span><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">res</span><span class="hl-1"> = </span><span class="hl-3">fileRoute</span><span class="hl-1">(); </span><span class="hl-10">// 不需要传递body</span><br/><span class="hl-1">    ...</span><br/><span class="hl-1">    </span><span class="hl-3">drop</span><span class="hl-1">(); </span><span class="hl-10">// 从此向下的调用不能再通过observe访问body</span><br/><span class="hl-1">    </span><span class="hl-8">return</span><span class="hl-1"> </span><span class="hl-5">res</span><br/><span class="hl-1">}</span><br/><br/><span class="hl-10">// service/fileUpload.ts</span><br/><span class="hl-8">import</span><span class="hl-1"> {</span><span class="hl-5">observe</span><span class="hl-1">} </span><span class="hl-8">from</span><span class="hl-1"> </span><span class="hl-4">&quot;../main&quot;</span><span class="hl-1">;</span><br/><span class="hl-8">import</span><span class="hl-1"> {</span><span class="hl-5">writeFile</span><span class="hl-1">} </span><span class="hl-8">from</span><span class="hl-1"> </span><span class="hl-4">&quot;fs/promises&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-8">export</span><span class="hl-1"> </span><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-3">uploadService</span><span class="hl-1"> = (</span><span class="hl-5">filepath</span><span class="hl-1">: </span><span class="hl-7">string</span><span class="hl-1">) </span><span class="hl-0">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">body</span><span class="hl-1"> = </span><span class="hl-3">observe</span><span class="hl-1">(); </span><span class="hl-10">// 获得body</span><br/><span class="hl-1">    </span><span class="hl-8">return</span><span class="hl-1"> </span><span class="hl-3">writeFile</span><span class="hl-1">(</span><span class="hl-5">filepath</span><span class="hl-1">, </span><span class="hl-5">body</span><span class="hl-1">)</span><br/><span class="hl-1">}</span>
</code></pre>
<blockquote>
<p>需要注意的以下几点：</p>
<ul>
<li><code>createFlare</code>是完全独立的函数，可以在任何时机执行，但它返回的三个函数都只能在<code>main</code>的直接或间接调用中执行，否则会抛出错误</li>
<li>静态分析时<code>assign</code>，<code>observe</code>和<code>drop</code>并不能判断要获取的值是否处于有效期，因此这三个函数会在不符合执行条件的情况下抛出错误。（而不是返回<code>undefined</code>或<code>null</code>）。你应该尽量避免在<code>if</code>分支中使用<code>assign</code>，正确的做法是<code>assign</code>一个可能为空的值，在使用时判断类型。</li>
<li><code>drop</code>函数不是必须执行的，<code>createFlare</code>内部使用的是<code>WeakMap</code>实现的，不必担心内存溢出的问题。</li>
</ul>
</blockquote>

<a href="#包装器" id="包装器" style="color: inherit; text-decoration: none;">
  <h2>包装器</h2>
</a>
<p>开发者可能会希望在一个函数执行前后分别执行一些代码，这些代码可能是可服复用的，也有可能只是希望这些逻辑被排除在核心逻辑之外，出于这样的需求，Freesia 提供了两个包装器创建函数：<code>createEffect</code>和<code>createWrapper</code>。</p>

<a href="#副作用包装" id="副作用包装" style="color: inherit; text-decoration: none;">
  <h3>副作用包装</h3>
</a>
<p>如果我们的包装逻辑并不修改原始函数的输入输出，可以使用副作用包装器<code>createEffect</code>。例如，要测量响应逻辑耗时：</p>
<pre><code class="language-ts"><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-3">main</span><span class="hl-1"> = </span><span class="hl-0">async</span><span class="hl-1"> (</span><span class="hl-5">req</span><span class="hl-1">: </span><span class="hl-7">HttpReq</span><span class="hl-1">) </span><span class="hl-0">=&gt;</span><span class="hl-1"> </span><span class="hl-3">createRes</span><span class="hl-1">();</span><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">timeMeasure</span><span class="hl-1"> = </span><span class="hl-3">createEffect</span><span class="hl-1">&lt;</span><span class="hl-0">typeof</span><span class="hl-1"> </span><span class="hl-5">main</span><span class="hl-1">&gt;((</span><span class="hl-5">req</span><span class="hl-1">) </span><span class="hl-0">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">start</span><span class="hl-1"> = </span><span class="hl-0">new</span><span class="hl-1"> </span><span class="hl-7">Date</span><span class="hl-1">();</span><br/><span class="hl-1">    </span><span class="hl-8">return</span><span class="hl-1"> (</span><span class="hl-5">res</span><span class="hl-1">) </span><span class="hl-0">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">        </span><span class="hl-5">console</span><span class="hl-1">.</span><span class="hl-3">log</span><span class="hl-1">(</span><span class="hl-4">`Use </span><span class="hl-0">${</span><span class="hl-0">new</span><span class="hl-6"> </span><span class="hl-7">Date</span><span class="hl-6">().</span><span class="hl-3">getTime</span><span class="hl-6">() </span><span class="hl-1">-</span><span class="hl-6"> </span><span class="hl-5">start</span><span class="hl-6">.</span><span class="hl-3">getTime</span><span class="hl-6">()</span><span class="hl-0">}</span><span class="hl-4">ms`</span><span class="hl-1">);</span><br/><span class="hl-1">    };</span><br/><span class="hl-1">});</span><br/><span class="hl-8">export</span><span class="hl-1"> </span><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">mainWithTimeMeasure</span><span class="hl-1"> = </span><span class="hl-3">timeMeasure</span><span class="hl-1">(</span><span class="hl-5">main</span><span class="hl-1">);</span>
</code></pre>
<p>我们会注意到，其实这个例子中的副作用和函数本身是无关的，对于这样的副作用我们可以使用<code>createEffect4Any</code>来创建，并且用到任何类型的函数上，例如：</p>
<pre><code class="language-ts"><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">timeMeasure</span><span class="hl-1"> = </span><span class="hl-3">createEffect4Any</span><span class="hl-1">(() </span><span class="hl-0">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">start</span><span class="hl-1"> = </span><span class="hl-0">new</span><span class="hl-1"> </span><span class="hl-7">Date</span><span class="hl-1">();</span><br/><span class="hl-1">    </span><span class="hl-8">return</span><span class="hl-1"> () </span><span class="hl-0">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">        </span><span class="hl-5">console</span><span class="hl-1">.</span><span class="hl-3">log</span><span class="hl-1">(</span><span class="hl-4">`Use </span><span class="hl-0">${</span><span class="hl-0">new</span><span class="hl-6"> </span><span class="hl-7">Date</span><span class="hl-6">().</span><span class="hl-3">getTime</span><span class="hl-6">() </span><span class="hl-1">-</span><span class="hl-6"> </span><span class="hl-5">start</span><span class="hl-6">.</span><span class="hl-3">getTime</span><span class="hl-6">()</span><span class="hl-0">}</span><span class="hl-4">ms`</span><span class="hl-1">);</span><br/><span class="hl-1">    };</span><br/><span class="hl-1">});</span><br/><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-3">fibbonnaci</span><span class="hl-1"> = (</span><span class="hl-5">index</span><span class="hl-1">: </span><span class="hl-7">number</span><span class="hl-1">): </span><span class="hl-7">number</span><span class="hl-1"> </span><span class="hl-0">=&gt;</span><br/><span class="hl-1">    !</span><span class="hl-7">Number</span><span class="hl-1">.</span><span class="hl-3">isInteger</span><span class="hl-1">(</span><span class="hl-5">index</span><span class="hl-1">) || </span><span class="hl-5">index</span><span class="hl-1"> &lt; </span><span class="hl-9">0</span><br/><span class="hl-1">        ? </span><span class="hl-9">0</span><br/><span class="hl-1">        : </span><span class="hl-5">index</span><span class="hl-1"> === </span><span class="hl-9">0</span><span class="hl-1"> || </span><span class="hl-5">index</span><span class="hl-1"> === </span><span class="hl-9">1</span><br/><span class="hl-1">        ? </span><span class="hl-9">1</span><br/><span class="hl-1">        : </span><span class="hl-3">fibbonnaci</span><span class="hl-1">(</span><span class="hl-5">index</span><span class="hl-1"> - </span><span class="hl-9">2</span><span class="hl-1">) + </span><span class="hl-3">fibbonnaci</span><span class="hl-1">(</span><span class="hl-5">index</span><span class="hl-1"> - </span><span class="hl-9">1</span><span class="hl-1">);</span><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-3">getBuffer</span><span class="hl-1"> = (</span><span class="hl-5">origin</span><span class="hl-1">: </span><span class="hl-7">string</span><span class="hl-1">) </span><span class="hl-0">=&gt;</span><span class="hl-1"> </span><span class="hl-5">Buffer</span><span class="hl-1">.</span><span class="hl-3">from</span><span class="hl-1">(</span><span class="hl-5">origin</span><span class="hl-1">);</span><br/><span class="hl-8">export</span><span class="hl-1"> </span><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">fibbonnaciWithTime</span><span class="hl-1"> = </span><span class="hl-3">timeMeasure</span><span class="hl-1">(</span><span class="hl-5">fibbonnaci</span><span class="hl-1">); </span><span class="hl-10">// number =&gt; number</span><br/><span class="hl-8">export</span><span class="hl-1"> </span><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">getBufferWithTime</span><span class="hl-1"> = </span><span class="hl-3">timeMeasure</span><span class="hl-1">(</span><span class="hl-5">getBuffer</span><span class="hl-1">); </span><span class="hl-10">// string =&gt; Buffer</span>
</code></pre>
<p>包裹后的函数依然保持了原有的入参和返回类型。</p>

<a href="#函数包装" id="函数包装" style="color: inherit; text-decoration: none;">
  <h3>函数包装</h3>
</a>
<p>另一种情况下，我们可能会使用外部逻辑修改原始函数的输入输出，甚至改变参数的输入类型，例如：</p>
<pre><code class="language-ts"><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-3">main</span><span class="hl-1"> = </span><span class="hl-0">async</span><span class="hl-1"> (</span><span class="hl-5">req</span><span class="hl-1">: </span><span class="hl-7">HttpReq</span><span class="hl-1">, </span><span class="hl-5">body</span><span class="hl-1">: </span><span class="hl-7">Buffer</span><span class="hl-1">) </span><span class="hl-0">=&gt;</span><span class="hl-1"> </span><span class="hl-3">createRes</span><span class="hl-1">();</span><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">bodyParser</span><span class="hl-1"> = </span><span class="hl-3">createWrapper</span><span class="hl-1">&lt;(</span><span class="hl-5">req</span><span class="hl-1">: </span><span class="hl-7">HttpReq</span><span class="hl-1">) </span><span class="hl-0">=&gt;</span><span class="hl-1"> </span><span class="hl-7">AsyncResponse</span><span class="hl-1">, </span><span class="hl-0">typeof</span><span class="hl-1"> </span><span class="hl-5">main</span><span class="hl-1">&gt;(</span><br/><span class="hl-1">    </span><span class="hl-0">async</span><span class="hl-1"> (</span><span class="hl-5">req</span><span class="hl-1">) </span><span class="hl-0">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">        </span><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">body</span><span class="hl-1"> = </span><span class="hl-8">await</span><span class="hl-1"> </span><span class="hl-3">rawBody</span><span class="hl-1">(</span><span class="hl-5">req</span><span class="hl-1">);</span><br/><span class="hl-1">        </span><span class="hl-8">return</span><span class="hl-1"> [</span><br/><span class="hl-1">            [</span><span class="hl-5">req</span><span class="hl-1">, </span><span class="hl-5">body</span><span class="hl-1">],</span><br/><span class="hl-1">            (</span><span class="hl-5">res</span><span class="hl-1">) </span><span class="hl-0">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">                </span><span class="hl-5">res</span><span class="hl-1">.</span><span class="hl-3">setHeaders</span><span class="hl-1">([</span><span class="hl-4">&quot;Keep-Alive&quot;</span><span class="hl-1">, </span><span class="hl-4">&quot;timeout=10&quot;</span><span class="hl-1">]);</span><br/><span class="hl-1">                </span><span class="hl-8">return</span><span class="hl-1"> </span><span class="hl-5">res</span><span class="hl-1">;</span><br/><span class="hl-1">            },</span><br/><span class="hl-1">        ];</span><br/><span class="hl-1">    }</span><br/><span class="hl-1">);</span><br/><span class="hl-8">export</span><span class="hl-1"> </span><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">withBodyParser</span><span class="hl-1"> = </span><span class="hl-3">bodyParser</span><span class="hl-1">(</span><span class="hl-5">main</span><span class="hl-1">);</span>
</code></pre>

<a href="#函数工具" id="函数工具" style="color: inherit; text-decoration: none;">
  <h2>函数工具</h2>
</a>

<a href="#basecompose-和-composefn" id="basecompose-和-composefn" style="color: inherit; text-decoration: none;">
  <h3>baseCompose 和 composeFn</h3>
</a>
<p><code>baseCompose</code>可以将两个函数连接起来，例如：</p>
<pre><code class="language-ts"><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">fn</span><span class="hl-1"> = </span><span class="hl-3">baseCompose</span><span class="hl-1">(</span><br/><span class="hl-1">    (</span><span class="hl-5">x</span><span class="hl-1">: </span><span class="hl-7">number</span><span class="hl-1">) </span><span class="hl-0">=&gt;</span><span class="hl-1"> </span><span class="hl-5">x</span><span class="hl-1"> + </span><span class="hl-9">1</span><span class="hl-1">,</span><br/><span class="hl-1">    (</span><span class="hl-5">x</span><span class="hl-1">) </span><span class="hl-0">=&gt;</span><span class="hl-1"> </span><span class="hl-7">Math</span><span class="hl-1">.</span><span class="hl-3">pow</span><span class="hl-1">(</span><span class="hl-5">x</span><span class="hl-1">, </span><span class="hl-9">2</span><span class="hl-1">)</span><br/><span class="hl-1">);</span><br/><span class="hl-3">fn</span><span class="hl-1">(</span><span class="hl-9">1</span><span class="hl-1">); </span><span class="hl-10">// 返回值为4</span>
</code></pre>
<p><code>composeFn</code>可以连接更多的函数：</p>
<pre><code class="language-ts"><span class="hl-0">const</span><span class="hl-1"> { </span><span class="hl-2">fn</span><span class="hl-1"> } = </span><span class="hl-3">composeFn</span><span class="hl-1">((</span><span class="hl-5">x</span><span class="hl-1">: </span><span class="hl-7">number</span><span class="hl-1">) </span><span class="hl-0">=&gt;</span><span class="hl-1"> </span><span class="hl-5">x</span><span class="hl-1"> + </span><span class="hl-9">1</span><span class="hl-1">)</span><br/><span class="hl-1">    .</span><span class="hl-3">next</span><span class="hl-1">((</span><span class="hl-5">x</span><span class="hl-1">) </span><span class="hl-0">=&gt;</span><span class="hl-1"> </span><span class="hl-7">Math</span><span class="hl-1">.</span><span class="hl-3">pow</span><span class="hl-1">(</span><span class="hl-5">x</span><span class="hl-1">, </span><span class="hl-9">2</span><span class="hl-1">))</span><br/><span class="hl-1">    .</span><span class="hl-3">next</span><span class="hl-1">(</span><span class="hl-5">fibbonnaci</span><span class="hl-1">);</span>
</code></pre>

<a href="#compute-和-computelazy" id="compute-和-computelazy" style="color: inherit; text-decoration: none;">
  <h3>compute 和 computeLazy</h3>
</a>

<a href="#computation" id="computation" style="color: inherit; text-decoration: none;">
  <h4>Computation</h4>
</a>
<p>使用<code>compute</code>创建<code>Computation&lt;T&gt;</code>对象。</p>
<pre><code class="language-ts"><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">credentialInfo</span><span class="hl-1"> = </span><span class="hl-3">compute</span><span class="hl-1">(</span><span class="hl-5">tokenBuf</span><span class="hl-1"> </span><span class="hl-10">/** Buffer */</span><span class="hl-1">)</span><br/><span class="hl-1">    .</span><span class="hl-3">map</span><span class="hl-1">((</span><span class="hl-5">buf</span><span class="hl-1">) </span><span class="hl-0">=&gt;</span><span class="hl-1"> </span><span class="hl-5">buf</span><span class="hl-1">.</span><span class="hl-3">toString</span><span class="hl-1">(</span><span class="hl-4">&quot;utf-8&quot;</span><span class="hl-1">))</span><br/><span class="hl-1">    .</span><span class="hl-3">map</span><span class="hl-1">(</span><span class="hl-5">parseToken</span><span class="hl-1">) </span><span class="hl-10">// parseToken 是一个异步函数</span><br/><span class="hl-1">    .</span><span class="hl-3">aMapSkipNull</span><span class="hl-1">((</span><span class="hl-5">token</span><span class="hl-1">) </span><span class="hl-0">=&gt;</span><span class="hl-1"> (</span><span class="hl-3">outDated</span><span class="hl-1">(</span><span class="hl-5">token</span><span class="hl-1">) ? </span><span class="hl-0">null</span><span class="hl-1"> : </span><span class="hl-5">token</span><span class="hl-1">))</span><br/><span class="hl-1">    .</span><span class="hl-3">aMapSkipNull</span><span class="hl-1">((</span><span class="hl-5">token</span><span class="hl-1">) </span><span class="hl-0">=&gt;</span><span class="hl-1"> </span><span class="hl-5">token</span><span class="hl-1">.</span><span class="hl-5">username</span><span class="hl-1">).</span><span class="hl-5">value</span><span class="hl-1">; </span><span class="hl-10">// -&gt; Promise&lt;string | null&gt;</span>
</code></pre>
<p>它包含 4 种链式调用方法：</p>
<ul>
<li>map：将一个函数应用于内部的值</li>
<li>mapSkipNull：将一个函数应用于内部的值，但如果原始值为 null 或 undefined，保持原始值</li>
<li>aMap：将一个函数应用于内部的值，若原始值是 Promise 包裹的，函数在对象的 then 中调用；函数的返回值总是被 Promise 包裹的</li>
<li>aMapSkipNull：将一个函数应用于内部的值，若原始值为<code>undefined|null|Promise&lt;undefined|null&gt;</code>，则保持原始值并用 Promise 包裹</li>
</ul>
<p>所有四个方法都会返回一个新的<code>Computation</code>对象，如果你将这个对象分发到多处，进入不同的链中，会得到互不影响的多个结果。</p>

<a href="#lazy" id="lazy" style="color: inherit; text-decoration: none;">
  <h4>Lazy</h4>
</a>
<p>使用<code>computeLazy</code>创建<code>Lazy&lt;T&gt;</code>对象，它包含的链式方法和<code>Computation</code>完全一致。</p>
<p>区别在于，<code>Computation</code>在每次链式调用时进行计算，而<code>Lazy</code>仅仅组合函数。当你访问一个<code>Lazy</code>对象的<code>value</code>属性时，才会将初始值带入组合好的函数进行计算。需要注意的是，每次访问<code>value</code>都会进行计算，如果函数中包含副作用，你应该将<code>value</code>的值取出使用。</p>
<p>同样的，每次进行链式调用都会返回新的<code>Lazy</code>对象，当分叉前注册的函数都是纯函数时，进入不同链的计算结果互不干扰。</p>
</div></div><div class="col-4 col-menu menu-sticky-wrap menu-highlight"><nav class="tsd-navigation primary"><ul><li class="current"><a href="modules.html">Exports</a></li><li class=" tsd-kind-namespace"><a href="modules/createSwRt.html">create<wbr/>Sw<wbr/>Rt</a></li><li class=" tsd-kind-namespace"><a href="modules/createSwRtX.html">create<wbr/>Sw<wbr/>RtX</a></li></ul></nav><nav class="tsd-navigation secondary menu-sticky"><ul><li class="tsd-kind-interface"><a href="interfaces/ResponseProps.html" class="tsd-kind-icon">Response<wbr/>Props</a></li><li class="tsd-kind-type-alias"><a href="modules.html#ResponseBody" class="tsd-kind-icon">Response<wbr/>Body</a></li><li class="tsd-kind-type-alias"><a href="modules.html#AsyncResponse" class="tsd-kind-icon">Async<wbr/>Response</a></li><li class="tsd-kind-class"><a href="classes/Respond.html" class="tsd-kind-icon">Respond</a></li><li class="tsd-kind-function"><a href="modules.html#createRes" class="tsd-kind-icon">create<wbr/>Res</a></li><li class="tsd-kind-type-alias"><a href="modules.html#HeaderValue" class="tsd-kind-icon">Header<wbr/>Value</a></li><li class="tsd-kind-type-alias"><a href="modules.html#HeaderObject" class="tsd-kind-icon">Header<wbr/>Object</a></li><li class="tsd-kind-type-alias"><a href="modules.html#HeaderArray" class="tsd-kind-icon">Header<wbr/>Array</a></li><li class="tsd-kind-type-alias"><a href="modules.html#HeaderCollection" class="tsd-kind-icon">Header<wbr/>Collection</a></li><li class="tsd-kind-enum"><a href="enums/Status.html" class="tsd-kind-icon">Status</a></li><li class="tsd-kind-type-alias"><a href="modules.html#HttpReq" class="tsd-kind-icon">Http<wbr/>Req</a></li><li class="tsd-kind-type-alias"><a href="modules.html#HttpRes" class="tsd-kind-icon">Http<wbr/>Res</a></li><li class="tsd-kind-type-alias"><a href="modules.html#ReqHandler" class="tsd-kind-icon">Req<wbr/>Handler</a></li><li class="tsd-kind-type-alias"><a href="modules.html#EntryPoint" class="tsd-kind-icon">Entry<wbr/>Point</a></li><li class="tsd-kind-function"><a href="modules.html#useRequest" class="tsd-kind-icon">use<wbr/>Request</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#useURL" class="tsd-kind-icon">useURL</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#createFlare" class="tsd-kind-icon">create<wbr/>Flare</a></li><li class="tsd-kind-function"><a href="modules.html#shimHTTP" class="tsd-kind-icon">shimHTTP</a></li><li class="tsd-kind-interface tsd-has-type-parameter"><a href="interfaces/ConditionInit.html" class="tsd-kind-icon">Condition<wbr/>Init</a></li><li class="tsd-kind-interface tsd-has-type-parameter"><a href="interfaces/Condition.html" class="tsd-kind-icon">Condition</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#condition" class="tsd-kind-icon">condition</a></li><li class="tsd-kind-type-alias tsd-has-type-parameter"><a href="modules.html#RouteHandler" class="tsd-kind-icon">Route<wbr/>Handler</a></li><li class="tsd-kind-type-alias tsd-has-type-parameter"><a href="modules.html#Route" class="tsd-kind-icon">Route</a></li><li class="tsd-kind-type-alias tsd-has-type-parameter"><a href="modules.html#RouteHandlerX" class="tsd-kind-icon">Route<wbr/>HandlerX</a></li><li class="tsd-kind-type-alias tsd-has-type-parameter"><a href="modules.html#RouteX" class="tsd-kind-icon">RouteX</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#createRoute" class="tsd-kind-icon">create<wbr/>Route</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#createRouteX" class="tsd-kind-icon">create<wbr/>RouteX</a></li><li class="tsd-kind-type-alias"><a href="modules.html#RouteChainInit" class="tsd-kind-icon">Route<wbr/>Chain<wbr/>Init</a></li><li class="tsd-kind-type-alias tsd-has-type-parameter"><a href="modules.html#RouteChainAdder" class="tsd-kind-icon">Route<wbr/>Chain<wbr/>Adder</a></li><li class="tsd-kind-type-alias tsd-has-type-parameter"><a href="modules.html#RouteChainFallback" class="tsd-kind-icon">Route<wbr/>Chain<wbr/>Fallback</a></li><li class="tsd-kind-type-alias tsd-has-type-parameter"><a href="modules.html#RouteChain" class="tsd-kind-icon">Route<wbr/>Chain</a></li><li class="tsd-kind-type-alias"><a href="modules.html#RouteChainInitX" class="tsd-kind-icon">Route<wbr/>Chain<wbr/>InitX</a></li><li class="tsd-kind-type-alias tsd-has-type-parameter"><a href="modules.html#RouteChainAdderX" class="tsd-kind-icon">Route<wbr/>Chain<wbr/>AdderX</a></li><li class="tsd-kind-type-alias tsd-has-type-parameter"><a href="modules.html#RouteChainFallbackX" class="tsd-kind-icon">Route<wbr/>Chain<wbr/>FallbackX</a></li><li class="tsd-kind-type-alias tsd-has-type-parameter"><a href="modules.html#RouteChainX" class="tsd-kind-icon">Route<wbr/>ChainX</a></li><li class="tsd-kind-function"><a href="modules.html#createSwRt" class="tsd-kind-icon">create<wbr/>Sw<wbr/>Rt</a></li><li class="tsd-kind-function"><a href="modules.html#createSwRtX" class="tsd-kind-icon">create<wbr/>Sw<wbr/>RtX</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#createSwitcher" class="tsd-kind-icon">create<wbr/>Switcher</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#createSwitcherX" class="tsd-kind-icon">create<wbr/>SwitcherX</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#allowMethods" class="tsd-kind-icon">allow<wbr/>Methods</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#All" class="tsd-kind-icon">All</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#Get" class="tsd-kind-icon">Get</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#Head" class="tsd-kind-icon">Head</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#Post" class="tsd-kind-icon">Post</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#Put" class="tsd-kind-icon">Put</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#Delete" class="tsd-kind-icon">Delete</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#Connect" class="tsd-kind-icon">Connect</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#Options" class="tsd-kind-icon">Options</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#Trace" class="tsd-kind-icon">Trace</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#Patch" class="tsd-kind-icon">Patch</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#allowMethodsX" class="tsd-kind-icon">allow<wbr/>MethodsX</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#AllX" class="tsd-kind-icon">AllX</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#GetX" class="tsd-kind-icon">GetX</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#HeadX" class="tsd-kind-icon">HeadX</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#PostX" class="tsd-kind-icon">PostX</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#PutX" class="tsd-kind-icon">PutX</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#DeleteX" class="tsd-kind-icon">DeleteX</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#ConnectX" class="tsd-kind-icon">ConnectX</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#OptionsX" class="tsd-kind-icon">OptionsX</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#TraceX" class="tsd-kind-icon">TraceX</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#PatchX" class="tsd-kind-icon">PatchX</a></li><li class="tsd-kind-type-alias"><a href="modules.html#Empty" class="tsd-kind-icon">Empty</a></li><li class="tsd-kind-type-alias tsd-has-type-parameter"><a href="modules.html#ParamFlag" class="tsd-kind-icon">Param<wbr/>Flag</a></li><li class="tsd-kind-type-alias tsd-has-type-parameter"><a href="modules.html#RoutePattern" class="tsd-kind-icon">Route<wbr/>Pattern</a></li><li class="tsd-kind-type-alias tsd-has-type-parameter"><a href="modules.html#RouteParam" class="tsd-kind-icon">Route<wbr/>Param</a></li><li class="tsd-kind-type-alias tsd-has-type-parameter"><a href="modules.html#MaybePromise" class="tsd-kind-icon">Maybe<wbr/>Promise</a></li><li class="tsd-kind-type-alias"><a href="modules.html#EncodingType" class="tsd-kind-icon">Encoding<wbr/>Type</a></li><li class="tsd-kind-function"><a href="modules.html#contentType" class="tsd-kind-icon">content<wbr/>Type</a></li><li class="tsd-kind-function"><a href="modules.html#contentLength" class="tsd-kind-icon">content<wbr/>Length</a></li><li class="tsd-kind-function"><a href="modules.html#contentDisposition" class="tsd-kind-icon">content<wbr/>Disposition</a></li><li class="tsd-kind-function"><a href="modules.html#contentEncoding" class="tsd-kind-icon">content<wbr/>Encoding</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#contentLanguage" class="tsd-kind-icon">content<wbr/>Language</a></li><li class="tsd-kind-function"><a href="modules.html#serverHeader" class="tsd-kind-icon">server<wbr/>Header</a></li><li class="tsd-kind-function"><a href="modules.html#location" class="tsd-kind-icon">location</a></li><li class="tsd-kind-function"><a href="modules.html#acceptRanges" class="tsd-kind-icon">accept<wbr/>Ranges</a></li><li class="tsd-kind-interface tsd-has-type-parameter"><a href="interfaces/Composer.html" class="tsd-kind-icon">Composer</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#baseCompose" class="tsd-kind-icon">base<wbr/>Compose</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#composeFn" class="tsd-kind-icon">compose<wbr/>Fn</a></li><li class="tsd-kind-interface tsd-has-type-parameter"><a href="interfaces/Computation.html" class="tsd-kind-icon">Computation</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#compute" class="tsd-kind-icon">compute</a></li><li class="tsd-kind-interface tsd-has-type-parameter"><a href="interfaces/Lazy.html" class="tsd-kind-icon">Lazy</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#lazy" class="tsd-kind-icon">lazy</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#computeLazy" class="tsd-kind-icon">compute<wbr/>Lazy</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#createEffect" class="tsd-kind-icon">create<wbr/>Effect</a></li><li class="tsd-kind-function"><a href="modules.html#createEffect4Any" class="tsd-kind-icon">create<wbr/>Effect4<wbr/>Any</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#addEffect" class="tsd-kind-icon">add<wbr/>Effect</a></li><li class="tsd-kind-type-alias"><a href="modules.html#Fn" class="tsd-kind-icon">Fn</a></li><li class="tsd-kind-type-alias"><a href="modules.html#AsyncFn" class="tsd-kind-icon">Async<wbr/>Fn</a></li><li class="tsd-kind-type-alias tsd-has-type-parameter"><a href="modules.html#BeforeHookArray" class="tsd-kind-icon">Before<wbr/>Hook<wbr/>Array</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#echo" class="tsd-kind-icon">echo</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#createWrapper" class="tsd-kind-icon">create<wbr/>Wrapper</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#addWrapper" class="tsd-kind-icon">add<wbr/>Wrapper</a></li><li class="tsd-kind-function tsd-has-type-parameter"><a href="modules.html#isVoid" class="tsd-kind-icon">is<wbr/>Void</a></li><li class="tsd-kind-interface"><a href="interfaces/HasToJSON.html" class="tsd-kind-icon">Has<wbr/>ToJSON</a></li><li class="tsd-kind-type-alias"><a href="modules.html#BasicJSONTypes" class="tsd-kind-icon">BasicJSONTypes</a></li><li class="tsd-kind-type-alias"><a href="modules.html#JsonObject" class="tsd-kind-icon">Json<wbr/>Object</a></li><li class="tsd-kind-type-alias"><a href="modules.html#JsonArray" class="tsd-kind-icon">Json<wbr/>Array</a></li><li class="tsd-kind-type-alias"><a href="modules.html#JsonType" class="tsd-kind-icon">Json<wbr/>Type</a></li><li class="tsd-kind-function"><a href="modules.html#resJson" class="tsd-kind-icon">res<wbr/>Json</a></li></ul></nav></div></div></div><footer class="with-border-bottom"><div class="container"><h2>Legend</h2><div class="tsd-legend-group"><ul class="tsd-legend"><li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li><li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li></ul><ul class="tsd-legend"><li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li><li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li></ul><ul class="tsd-legend"><li class="tsd-kind-property tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private property</span></li></ul><ul class="tsd-legend"><li class="tsd-kind-method tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static method</span></li></ul></div><h2>Settings</h2><p>Theme <select id="theme"><option value="os">OS</option><option value="light">Light</option><option value="dark">Dark</option></select></p></div></footer><div class="container tsd-generator"><p>Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p></div><div class="overlay"></div><script src="assets/main.js"></script></body></html>